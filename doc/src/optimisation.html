<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>OptimisedWasteNetworksPy.src.optimisation API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>OptimisedWasteNetworksPy.src.optimisation</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import gurobipy as gp
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib.offsetbox as osb
import matplotlib.lines as mlines
import utils.get_coords as gc
import utils.convert_coords as cc
import re
import math
import numpy as np
import seaborn as sns
import subprocess
import sys


class Infrastructure:
    &#34;&#34;&#34;
    ``Infrastructure class`` defines value-chain-specific parameters and builds
    up the optimisation problem utilising pyscipopt
    &#34;&#34;&#34;

    # define miscellaneous simulation variables
    env_cost = 170  # cost of the environmental impact [euro/ton CO2e]
    circuit_factor = 1.32  # average circuit factor for Germany []
    working_days = 330  # assume operation 330 day/year (7&#39;920h total) [days]
    # define transportation variables
    rolloff_load = 6  # maximum load for a roll-off [tons]
    rolloff_volume = 33  # maximum volume for a roll-off [m^3]
    tanker_volume = 45  # maximum volume for steel tanker [m^3]
    fuel_cons = 0.4  # fuel consumption [lt/km]
    fuel_price = 1.79  # fuel price [euro/lt]
    toll_cost = 0.198  # toll cost [euro/km]
    avg_speed = 60  # average driving speed [km/h]
    driver_wage = 45500  # driver wage [euro/year]
    driver_hours = 2070  # driver working hours [hours/year]
    vehicle_cost_rollof = 10000 / (15 * 360 * 90 / 14)  # roll-off [euro/h]
    vehicle_cost_tanker = 50000 / (15 * 360 * 90 / 14)  # steel tanker [euro/h]
    max_time = 100  # maximum transportation between facilities [hours]
    # define product physical variables
    rho_ETICS = 0.014  # density of ETICS [ton/m^3]
    rho_compressed_ETICS = 0.14  # density of compressed ETICS [ton/m^3]
    rho_pre_concentrate = 0.35  # density of pre-concentrate [ton/m^3]
    rho_pyrolysis_oil = 0.80  # density of pyrolysis oil [ton/m^3]
    rho_styrene = 0.910  # density of styrene [ton/m^3]
    # define economic variables
    ref_CAPEX_OCF = 0.057  # CAPEX of OCF for reference capacity [Meuro]
    ref_CAPEX_MPF = 8.0  # CAPEX of MPF for reference capacity [Meuro]
    ref_CAPEX_CPF = 10.11  # CAPEX of CPF for reference capacity [Meuro]
    ref_CAPEX_DPF = 5.17  # CAPEX of DPF for reference capacity [Meuro]
    ref_capacity_OCF = 140 / working_days  # OCF reference capacity [ton/day]
    ref_capacity_MPF = 15000 / working_days  # MPF reference capacity [ton/day]
    ref_capacity_CPF = 3960 / working_days  # CPF reference capacity [ton/day]
    ref_capacity_DPF = 14850 / working_days  # DPF reference capacity [ton/day]
    ref_fOPEX_OCF = 0.012  # reference fixed OPEX of OCF [Meuro/year]
    ref_fOPEX_MPF = 1.1  # reference fixed OPEX of MPF [Meuro/year]
    ref_fOPEX_CPF = 1.21  # reference fixed OPEX of CPF [Meuro/year]
    ref_fOPEX_DPF = 0.62  # reference fixed OPEX of DPF [Meuro/year]
    vOPEX_OCF = 11  # variable OPEX of OCF [euro/ton]
    vOPEX_MPF = 46  # variable OPEX of MPF [euro/ton]
    vOPEX_CPF = 108.68  # variable OPEX of CPF [euro/ton]
    vOPEX_DPF = 57.77  # variable OPEX of DPF [euro/ton]
    period = 10  # loan period [years]
    rate = 0.10  # discount rate []
    # define environmental impact variables
    env_rolloff = 5.6402e-4  # environmental impact of roll-off [tons CO2e/km]
    env_tanker = 1.0586e-4  # environmental impact of tanker [tons CO2e/km]
    CI_OCF = 2.808e-5  # construction impact of mech. plant [tons CO2e/ton]
    CI_MPF = 4.303e-3  # construction impact of mech. plant [tons CO2e/ton]
    CI_CPF = 0.816  # construction impact of chem. plant [tons CO2e/ton]
    CI_DPF = 0.218  # construction impact of chem. plant [tons CO2e/ton]
    OI_OCF = 1.250e-2  # operational impact of OCF [tons CO2e/ton]
    OI_MPF = 3.575e-2  # operational impact of MPF [tons CO2e/ton]
    OI_CPF = 0.524  # operational impact of CPF [tons CO2e/ton]
    OI_DPF = 1.156  # operational impact of DPF [tons CO2e/ton]

    def __init__(self, D1, D2, D3, D4, D5):
        &#34;&#34;&#34;
        Initialise ``Infrastructure`` object utilising DataFrames for the
        distance between facilities in the network.

        Parameters
        ----------
        D1 (DataFrame): distance matrix for S to OCF

        D2 (DataFrame): distance matrix for OCF to MPF

        D3 (DataFrame): distance matrix for MPF to CPF

        D4 (DataFrame): distance matrix for CPF to DPF

        D5 (DataFrame): distance matrix for DPF to C

        Notes
        -----
        User should be careful in naming facilities. Identical names cannot be
        used to name different facilities at the same location. For example, a
        source and collection facility in Cologne should have different names:
        S_Cologne and OCF_Cologne, for example.
        &#34;&#34;&#34;

        # initialise instance variables for distance matrices NOTE: multiplied
        # by circuit factor, only needed if use straight-line distance as is
        # currently being used
        self.D1 = D1 * self.circuit_factor
        self.D2 = D2 * self.circuit_factor
        self.D3 = D3 * self.circuit_factor
        self.D4 = D4 * self.circuit_factor
        self.D5 = D5 * self.circuit_factor
        # initialise instance variables for sources, customers &amp; facilities
        self.S = D1.index.tolist()
        self.OCF = D1.columns.tolist()
        self.MPF = D3.index.tolist()
        self.CPF = D3.columns.tolist()
        self.DPF = D5.index.tolist()
        self.C = D5.columns.tolist()

    def define_value_chain(
        self,
        products,
        source_capacity,
        facility_capacity,
        demand,
        yield_factor,
        market_price,
    ):
        &#34;&#34;&#34;
        Define the value chain by specifying product- and capacity-specific
        parameters.

        Parameters
        ----------
        products (list): contains names of products in value chain

        source_capacity (DataFrame): contains source capacities [tons]

        facility_capacity (dict): contains facilities as keys and capacities as
        values [tons]

        demand (list): contains demand of all products [tons]

        yield_factor (dict): contains product and facility type as keys and
        corresponding yield factors as values

        market_price (dict): contains products as keys and market price as
        values [euro/ton]
        &#34;&#34;&#34;

        # initialise instance variables from provided parameters
        self.P = products
        self.PP = products  # P subset used when products transformed @ facility
        self.source_cap = source_capacity
        self.yield_factor = yield_factor
        self.market_price = market_price
        self.facility_cap = facility_capacity

        # generate list with product and customer location pairs
        key_list_C = []
        for n in self.C:
            for p in self.P:
                key_list_C.append((p, n))
        self.key_list_C = key_list_C

        # generate instance dict that uses ``self.key_list_C`` as keys and
        # ``demand`` as values
        D = {}
        idx = 0
        for key in range(0, len(self.key_list_C)):
            D[self.key_list_C[key]] = demand[idx]
            idx += 1
            if idx &gt;= len(demand):
                idx = 0
        self.D = D

        # calculate total capital invesment cost wrt capacity [euro]
        self.TCI_OCF = (
            six_tenths_rule(
                self.ref_capacity_OCF, self.facility_cap[&#34;OCF&#34;], self.ref_CAPEX_OCF
            )
            * 10**6
        )
        self.TCI_MPF = (
            six_tenths_rule(
                self.ref_capacity_MPF, self.facility_cap[&#34;MPF&#34;], self.ref_CAPEX_MPF
            )
            * 10**6
        )
        self.TCI_CPF = (
            six_tenths_rule(
                self.ref_capacity_CPF, self.facility_cap[&#34;CPF&#34;], self.ref_CAPEX_CPF
            )
            * 10**6
        )
        self.TCI_DPF = (
            six_tenths_rule(
                self.ref_capacity_DPF, self.facility_cap[&#34;DPF&#34;], self.ref_CAPEX_DPF
            )
            * 10**6
        )

        # calculate fixed OPEX wrt capacity [euro/day]
        self.fOPEX_OCF = (
            six_tenths_rule(
                self.ref_capacity_OCF, self.facility_cap[&#34;OCF&#34;], self.ref_fOPEX_OCF
            )
            * 10**6
            / self.working_days
        )
        self.fOPEX_MPF = (
            six_tenths_rule(
                self.ref_capacity_MPF, self.facility_cap[&#34;MPF&#34;], self.ref_fOPEX_MPF
            )
            * 10**6
            / self.working_days
        )
        self.fOPEX_CPF = (
            six_tenths_rule(
                self.ref_capacity_CPF, self.facility_cap[&#34;CPF&#34;], self.ref_fOPEX_CPF
            )
            * 10**6
            / self.working_days
        )
        self.fOPEX_DPF = (
            six_tenths_rule(
                self.ref_capacity_DPF, self.facility_cap[&#34;DPF&#34;], self.ref_fOPEX_DPF
            )
            * 10**6
            / self.working_days
        )

        # calculate annualized capital investment cost per day [euro/day]
        self.ACI_OCF = (
            self.rate
            * self.TCI_OCF
            / (1 - (1 + self.rate) ** (-self.period))
            / self.working_days
        )
        self.ACI_MPF = (
            self.rate
            * self.TCI_MPF
            / (1 - (1 + self.rate) ** (-self.period))
            / self.working_days
        )
        self.ACI_CPF = (
            self.rate
            * self.TCI_CPF
            / (1 - (1 + self.rate) ** (-self.period))
            / self.working_days
        )
        self.ACI_DPF = (
            self.rate
            * self.TCI_DPF
            / (1 - (1 + self.rate) ** (-self.period))
            / self.working_days
        )

        # calculate transportation costs [euro/(km*ton)]
        # ETICS transported in roll-off, determine if volume- or load-limit
        self.TC_ETICS = (
            (self.fuel_price * self.fuel_cons + self.toll_cost)
            + (self.driver_wage / self.driver_hours + self.vehicle_cost_rollof)
            / self.avg_speed
        ) / min(self.rolloff_load, self.rolloff_volume * self.rho_ETICS)
        # compressed ETICS transported in roll-off, determine if v- or l-limit
        self.TC_comp_ETICS = (
            (self.fuel_price * self.fuel_cons + self.toll_cost)
            + (self.driver_wage / self.driver_hours + self.vehicle_cost_rollof)
            / self.avg_speed
        ) / min(self.rolloff_load, self.rolloff_volume * self.rho_compressed_ETICS)
        # pre-concentrate transported in roll-off, determine if v- or l-limit
        self.TC_pre_concentrate = (
            (self.fuel_price * self.fuel_cons + self.toll_cost)
            + (self.driver_wage / self.driver_hours + self.vehicle_cost_rollof)
            / self.avg_speed
        ) / min(self.rolloff_load, self.rolloff_volume * self.rho_pre_concentrate)
        # pyrolysis oil transported in tanker, volume-limited
        self.TC_pyrolysis_oil = (
            (self.fuel_price * self.fuel_cons + self.toll_cost)
            + (self.driver_wage / self.driver_hours + self.vehicle_cost_tanker)
            / self.avg_speed
        ) / (self.tanker_volume * self.rho_pyrolysis_oil)
        # styrene transported in tanker, volume-limited
        self.TC_styrene = (
            (self.fuel_price * self.fuel_cons + self.toll_cost)
            + (self.driver_wage / self.driver_hours + self.vehicle_cost_tanker)
            / self.avg_speed
        ) / (self.tanker_volume * self.rho_styrene)

        # calculate transportation environmental impact [tons CO2-eq/(km*ton)]
        # ETICS, compressed ETICS and pre-concentrate transported in roll-off
        self.TI_ETICS = self.env_rolloff
        self.TI_comp_ETICS = self.env_rolloff
        self.TI_pre_concentrate = self.env_rolloff
        # pyrolysis oil and styrene transported in tanker
        self.TI_pyrolysis_oil = self.env_tanker
        self.TI_styrene = self.env_tanker

    def model_value_chain(self, weight_economic, weight_environmental):
        &#34;&#34;&#34;
        Utilise gurobipy to define a multi-objective optimisation model for the
        user-defined value chain. The model is defined using gurobipy&#39;s blended
        multi-bojective functions. See note below for more information regarding
        how the weights work.

        Parameters
        ----------
        weight_economic (int): weight corresponding to the economic objective
        function

        weight_environmental (int): weight corresponding to the environmental
        objective function

        NOTE: the resulting multi-objective function will be a linear
        combination of the individual objective functions multiplied by their
        corresponding weights, i.e.: weight_economic * obj_economic +
        weight_environmental * obj_environmental
        &#34;&#34;&#34;

        # initialise optimisation problem
        model = gp.Model(&#34;value_chain&#34;)

        # initialise variables whose scope is this function
        b = {}  # binary variable, represents open/close decisions
        x = {}  # continuous variable, represents material flows

        # add solution variables to the optimisation problem
        # product flows from S to OCF
        for p in self.P:
            for i in self.S:
                for j in self.OCF:
                    # Source &gt; Collection Facility
                    x[p, i, j] = model.addVar(
                        vtype=&#34;CONTINUOUS&#34;, lb=0, name=&#34;x(%s,%s,%s)&#34; % (p, i, j)
                    )
        # product flows from OCF to MPF
        for p in self.P:
            for j in self.OCF:
                for k in self.MPF:
                    x[p, j, k] = model.addVar(
                        vtype=&#34;CONTINUOUS&#34;, lb=0, name=&#34;x(%s,%s,%s)&#34; % (p, j, k)
                    )
        # product flows from MPF to CPF
        for p in self.P:
            for k in self.MPF:
                for l in self.CPF:
                    x[p, k, l] = model.addVar(
                        vtype=&#34;CONTINUOUS&#34;, lb=0, name=&#34;x(%s,%s,%s)&#34; % (p, k, l)
                    )
        # product flows from CPF to DPF
        for p in self.P:
            for l in self.CPF:
                for m in self.DPF:
                    x[p, l, m] = model.addVar(
                        vtype=&#34;CONTINUOUS&#34;, lb=0, name=&#34;x(%s,%s,%s)&#34; % (p, l, m)
                    )
        # product flows from DPF to C
        for p in self.P:
            for m in self.DPF:
                for n in self.C:
                    x[p, m, n] = model.addVar(
                        vtype=&#34;CONTINUOUS&#34;, lb=0, name=&#34;x(%s,%s,%s)&#34; % (p, m, n)
                    )
        # OCF installation binary outcomes
        for j in self.OCF:
            b[j] = model.addVar(vtype=&#34;INTEGER&#34;, lb=0, name=&#34;b(%s)&#34; % j)
        # MPF installation binary outcomes
        for k in self.MPF:
            b[k] = model.addVar(vtype=&#34;INTEGER&#34;, lb=0, name=&#34;b(%s)&#34; % k)
        # CPF installation binary outcomes
        for l in self.CPF:
            b[l] = model.addVar(vtype=&#34;INTEGER&#34;, lb=0, name=&#34;b(%s)&#34; % l)
        # DPF installation binary outcomes
        for m in self.DPF:
            b[m] = model.addVar(vtype=&#34;INTEGER&#34;, lb=0, name=&#34;b(%s)&#34; % m)

        # add constraint for flow conservation at sources to the model
        for p in self.P:
            for i in self.S:
                model.addConstr(
                    gp.quicksum(x[p, i, j] for j in self.OCF)
                    == self.source_cap.loc[i, p],
                    name=&#34;Conservation(%s,%s)&#34; % (p, i),
                )

        # add constraints for flow conservation at facilities to the model
        for p in self.P:
            for j in self.OCF:
                # input ETICS, output compressed ETICS
                model.addConstr(
                    self.yield_factor[(p, &#34;OCF&#34;)]
                    * gp.quicksum(x[p, i, j] for i in self.S for p in self.PP)
                    == gp.quicksum(x[p, j, k] for k in self.MPF),
                    name=&#34;Conservation(%s,%s)&#34; % (p, j),
                )
            for k in self.MPF:
                # input compressed ETICS, output pre-concentrate
                model.addConstr(
                    self.yield_factor[(p, &#34;MPF&#34;)]
                    * gp.quicksum(x[p, j, k] for j in self.OCF for p in self.PP)
                    == gp.quicksum(x[p, k, l] for l in self.CPF),
                    name=&#34;Conservation(%s,%s)&#34; % (p, k),
                )
            for l in self.CPF:
                # input pre-concentrate, output pyrolysis oil
                model.addConstr(
                    self.yield_factor[(p, &#34;CPF&#34;)]
                    * gp.quicksum(x[p, k, l] for k in self.MPF for p in self.PP)
                    == gp.quicksum(x[p, l, m] for m in self.DPF),
                    name=&#34;Conservation(%s,%s)&#34; % (p, l),
                )
            for m in self.DPF:
                # input pyrolysis oil, output styrene
                model.addConstr(
                    self.yield_factor[(p, &#34;DPF&#34;)]
                    * gp.quicksum(x[p, l, m] for l in self.CPF for p in self.PP)
                    == gp.quicksum(x[p, m, n] for n in self.C),
                    name=&#34;Conservation(%s,%s)&#34; % (p, m),
                )

        # add capacity constraint for the facilities to the model
        for j in self.OCF:
            model.addConstr(
                gp.quicksum(x[p, i, j] for i in self.S for p in self.P)
                &lt;= b[j] * self.facility_cap[&#34;OCF&#34;],
                name=&#34;Capacity(%s)&#34; % j,
            )
        for k in self.MPF:
            model.addConstr(
                gp.quicksum(x[p, j, k] for j in self.OCF for p in self.P)
                &lt;= b[k] * self.facility_cap[&#34;MPF&#34;],
                name=&#34;Capacity(%s)&#34; % k,
            )
        for l in self.CPF:
            model.addConstr(
                gp.quicksum(x[p, k, l] for k in self.MPF for p in self.P)
                &lt;= b[l] * self.facility_cap[&#34;CPF&#34;],
                name=&#34;Capacity(%s)&#34; % l,
            )
        for m in self.DPF:
            model.addConstr(
                gp.quicksum(x[p, l, m] for l in self.CPF for p in self.P)
                &lt;= b[m] * self.facility_cap[&#34;DPF&#34;],
                name=&#34;Capacity(%s)&#34; % m,
            )

        # add demand satisfaction constraint to the model
        for p in self.P:
            for n in self.C:
                model.addConstr(
                    gp.quicksum(x[p, m, n] for m in self.DPF) &lt;= self.D[(p, n)],
                    name=&#34;Demand(%s,%s)&#34; % (p, n),
                )

        # add driving time constraint for OCFs to the model
        for i in self.S:
            for j in self.OCF:
                model.addConstr(
                    gp.quicksum(x[p, i, j] for p in self.P) * self.D1.loc[i, j]
                    &lt;= (gp.quicksum(x[p, i, j] for p in self.P))
                    * self.avg_speed
                    * self.max_time,
                    name=&#34;Travel Time(%s,%s)&#34; % (j, i),
                )

        # set Gurobi to maximize all objective functions
        model.ModelSense = gp.GRB.MAXIMIZE

        # add economic objective to the model (maximize)
        model.setObjectiveN(
            gp.quicksum(
                self.market_price[p]
                * gp.quicksum(x[p, m, n] for m in self.DPF for n in self.C)
                for p in self.P
            )
            - (
                gp.quicksum(self.ACI_OCF * b[j] for j in self.OCF)
                + gp.quicksum(self.ACI_MPF * b[k] for k in self.MPF)
                + gp.quicksum(self.ACI_CPF * b[l] for l in self.CPF)
                + gp.quicksum(self.ACI_DPF * b[m] for m in self.DPF)
            )
            - (
                gp.quicksum(
                    (
                        self.fOPEX_OCF * b[j]
                        + self.vOPEX_OCF
                        * gp.quicksum(x[p, i, j] for i in self.S for p in self.P)
                    )
                    for j in self.OCF
                )
                + gp.quicksum(
                    (
                        self.fOPEX_MPF * b[k]
                        + self.vOPEX_MPF
                        * gp.quicksum(x[p, j, k] for j in self.OCF for p in self.P)
                    )
                    for k in self.MPF
                )
                + gp.quicksum(
                    (
                        self.fOPEX_CPF * b[l]
                        + self.vOPEX_CPF
                        * gp.quicksum(x[p, k, l] for k in self.MPF for p in self.P)
                    )
                    for l in self.CPF
                )
                + gp.quicksum(
                    (
                        self.fOPEX_DPF * b[m]
                        + self.vOPEX_DPF
                        * gp.quicksum(x[p, l, m] for l in self.CPF for p in self.P)
                    )
                    for m in self.DPF
                )
            )
            - (
                gp.quicksum(
                    2 * self.D1.loc[i, j] * self.TC_ETICS * x[p, i, j]
                    for i in self.S
                    for j in self.OCF
                    for p in self.P
                )
                + gp.quicksum(
                    2 * self.D2.loc[j, k] * self.TC_comp_ETICS * x[p, j, k]
                    for j in self.OCF
                    for k in self.MPF
                    for p in self.P
                )
                + gp.quicksum(
                    2 * self.D3.loc[k, l] * self.TC_pre_concentrate * x[p, k, l]
                    for k in self.MPF
                    for l in self.CPF
                    for p in self.P
                )
                + gp.quicksum(
                    2 * self.D4.loc[l, m] * self.TC_pyrolysis_oil * x[p, l, m]
                    for l in self.CPF
                    for m in self.DPF
                    for p in self.P
                )
                + gp.quicksum(
                    2 * self.D5.loc[m, n] * self.TC_styrene * x[p, m, n]
                    for m in self.DPF
                    for n in self.C
                    for p in self.P
                )
            ),
            0,
            weight=weight_economic,
            name=&#34;obj_economic&#34;,
        )

        # add environmental objective to the model (minimize = -1 * maximize)
        # NOTE: convert to estimated economic cost so blended MOO works
        model.setObjectiveN(
            -1
            * self.env_cost
            * (
                gp.quicksum(
                    (self.CI_OCF + self.OI_OCF)
                    * gp.quicksum(x[p, i, j] for i in self.S for p in self.P)
                    for j in self.OCF
                )
                + gp.quicksum(
                    (self.CI_MPF + self.OI_MPF)
                    * gp.quicksum(x[p, j, k] for j in self.OCF for p in self.P)
                    for k in self.MPF
                )
                + gp.quicksum(
                    (self.CI_CPF + self.OI_CPF)
                    * gp.quicksum(x[p, k, l] for k in self.MPF for p in self.P)
                    for l in self.CPF
                )
                + gp.quicksum(
                    (self.CI_DPF + self.OI_DPF)
                    * gp.quicksum(x[p, l, m] for l in self.CPF for p in self.P)
                    for m in self.DPF
                )
                + gp.quicksum(
                    2 * self.D1.loc[i, j] * self.TI_ETICS * x[p, i, j]
                    for i in self.S
                    for j in self.OCF
                    for p in self.P
                )
                + gp.quicksum(
                    2 * self.D2.loc[j, k] * self.TI_comp_ETICS * x[p, j, k]
                    for j in self.OCF
                    for k in self.MPF
                    for p in self.P
                )
                + gp.quicksum(
                    2 * self.D3.loc[k, l] * self.TI_pre_concentrate * x[p, k, l]
                    for k in self.MPF
                    for l in self.CPF
                    for p in self.P
                )
                + gp.quicksum(
                    2 * self.D4.loc[l, m] * self.TI_pyrolysis_oil * x[p, l, m]
                    for l in self.CPF
                    for m in self.DPF
                    for p in self.P
                )
                + gp.quicksum(
                    2 * self.D5.loc[m, n] * self.TI_styrene * x[p, m, n]
                    for m in self.DPF
                    for n in self.C
                    for p in self.P
                )
            ),
            1,
            weight=weight_environmental,
            name=&#34;obj_environmental&#34;,
        )

        self.x = x
        self.b = b
        self.model = model

    def process_results(self):
        &#34;&#34;&#34;
        Process results for the optimised solution. This function accesses
        solution variables and computes other relevant secondary variables.
        NOTE: this function MUST be called if any further post-processing of the
        results is to be done.
        &#34;&#34;&#34;

        # extract resulting variable values and store them in a dictionary
        vars = {}
        for var in self.model.getVars():
            vars[f&#34;{var.varName}&#34;] = var.x

        # access and store both objective functions (profit &amp; environmental
        # impact expressed as an economic cost)
        self.obj_economic = self.model.getObjective(0).getValue()
        self.obj_environmental = -1 * self.model.getObjective(1).getValue()

        # create ``product_flow`` df for products flowing between facilities
        columns = [&#34;Origin&#34;, &#34;Destination&#34;, &#34;Product&#34;, &#34;Amount&#34;]
        self.product_flow = pd.DataFrame(columns=columns)

        # calculate and store the demand satisfaction
        demand_satisfaction = {}
        for p in self.P:
            for n in self.C:
                demand_satisfaction[(p, n)] = sum(
                    vars[f&#34;x({p},{m},{n})&#34;] for m in self.DPF
                )
        self.demand_satisfaction = demand_satisfaction

        # calculate and store the revenue
        self.Revenue = sum(
            sum(self.market_price[p] * self.demand_satisfaction[(p, n)] for n in self.C)
            for p in self.P
        )

        # process data related to installed OCFs
        name_list_OCF = []
        for j in self.OCF:
            if vars[f&#34;b({j})&#34;] &gt; 0.5:
                name_list_OCF.append(j)
            # add inflowing products to product_flow
            for p in self.P:
                for i in self.S:
                    if vars[f&#34;x({p},{i},{j})&#34;] &gt; 0.001:
                        # append flow data from i to j to DataFrame
                        new_data = {
                            &#34;Origin&#34;: i,
                            &#34;Destination&#34;: j,
                            &#34;Product&#34;: p,
                            &#34;Amount&#34;: vars[f&#34;x({p},{i},{j})&#34;],
                        }
                        self.product_flow = self.product_flow._append(
                            new_data, ignore_index=True
                        )
        self.name_list_OCF = name_list_OCF

        # process data related to installed MPFs
        name_list_MPF = []
        for k in self.MPF:
            if vars[f&#34;b({k})&#34;] &gt; 0.5:
                name_list_MPF.append(k)
            # add inflowing products to product_flow
            for p in self.P:
                for j in self.OCF:
                    if vars[f&#34;x({p},{j},{k})&#34;] &gt; 0.001:
                        # append flow data from j to k to DataFrame
                        new_data = {
                            &#34;Origin&#34;: j,
                            &#34;Destination&#34;: k,
                            &#34;Product&#34;: p,
                            &#34;Amount&#34;: vars[f&#34;x({p},{j},{k})&#34;],
                        }
                        self.product_flow = self.product_flow._append(
                            new_data, ignore_index=True
                        )
        self.name_list_MPF = name_list_MPF

        # process data related to installed CPFs
        name_list_CPF = []
        for l in self.CPF:
            if vars[f&#34;b({l})&#34;] &gt; 0.5:
                name_list_CPF.append(l)
            # add inflowing products to product_flow
            for p in self.P:
                for k in self.MPF:
                    if vars[f&#34;x({p},{k},{l})&#34;] &gt; 0.001:
                        # append flow data from k to l to DataFrame
                        new_data = {
                            &#34;Origin&#34;: k,
                            &#34;Destination&#34;: l,
                            &#34;Product&#34;: p,
                            &#34;Amount&#34;: vars[f&#34;x({p},{k},{l})&#34;],
                        }
                        self.product_flow = self.product_flow._append(
                            new_data, ignore_index=True
                        )
        self.name_list_CPF = name_list_CPF

        # process data related to installed DPFs
        name_list_DPF = []
        for m in self.DPF:
            if vars[f&#34;b({m})&#34;] &gt; 0.5:
                name_list_DPF.append(m)
            # add inflowing &amp; outflowing products to product flow
            for p in self.P:
                # inflowing products
                for l in self.CPF:
                    if vars[f&#34;x({p},{l},{m})&#34;] &gt; 0.001:
                        # append flow data from l to m to DataFrame
                        new_data = {
                            &#34;Origin&#34;: l,
                            &#34;Destination&#34;: m,
                            &#34;Product&#34;: p,
                            &#34;Amount&#34;: vars[f&#34;x({p},{l},{m})&#34;],
                        }
                        self.product_flow = self.product_flow._append(
                            new_data, ignore_index=True
                        )
                # outflowing products
                for n in self.C:
                    if vars[f&#34;x({p},{m},{n})&#34;] &gt; 0.001:
                        # append flow data from m to n to DataFrame
                        new_data = {
                            &#34;Origin&#34;: m,
                            &#34;Destination&#34;: n,
                            &#34;Product&#34;: p,
                            &#34;Amount&#34;: vars[f&#34;x({p},{m},{n})&#34;],
                        }
                        self.product_flow = self.product_flow._append(
                            new_data, ignore_index=True
                        )
        self.name_list_DPF = name_list_DPF

        # save the ``self.product_flow`` DataFrame to a csv file
        self.product_flow.to_csv(&#34;results/product_flow.csv&#34;)

        # compute demand satisfaction of all customers in value chain
        demand_satisfaction = {}
        for p in self.P:
            for n in self.C:
                demand_satisfaction[(p, n)] = sum(
                    vars[f&#34;x({p},{m},{n})&#34;] for m in self.DPF
                )
        self.demand_satisfaction = demand_satisfaction

        # compute individual elements of the economic objective function
        # revenue
        self.Revenue = sum(
            sum(self.market_price[p] * self.demand_satisfaction[(p, n)] for n in self.C)
            for p in self.P
        )
        # transportation costs
        # transportation costs between S and OCF
        self.transportation_cost_1 = sum(
            2
            * self.D1.loc[i, j]
            * self.TC_ETICS
            * sum(vars[f&#34;x({p},{i},{j})&#34;] for p in self.P)
            for i in self.S
            for j in self.OCF
        )
        # transportation costs between OCF and MPF
        self.transportation_cost_2 = sum(
            2
            * self.D2.loc[j, k]
            * self.TC_comp_ETICS
            * sum(vars[f&#34;x({p},{j},{k})&#34;] for p in self.P)
            for j in self.OCF
            for k in self.MPF
        )
        # transportation cost between MPF and CPF
        self.transportation_cost_3 = sum(
            2
            * self.D3.loc[k, l]
            * self.TC_pre_concentrate
            * sum(vars[f&#34;x({p},{k},{l})&#34;] for p in self.P)
            for k in self.MPF
            for l in self.CPF
        )
        # transportation cost between CPF and DPF
        self.transportation_cost_4 = sum(
            2
            * self.D4.loc[l, m]
            * self.TC_pyrolysis_oil
            * sum(vars[f&#34;x({p},{l},{m})&#34;] for p in self.P)
            for l in self.CPF
            for m in self.DPF
        )
        # transportation cost between DPF and C
        self.transportation_cost_5 = sum(
            2
            * self.D5.loc[m, n]
            * self.TC_styrene
            * sum(vars[f&#34;x({p},{m},{n})&#34;] for p in self.P)
            for m in self.DPF
            for n in self.C
        )
        # CAPEX of facilities in the value chain
        self.capex_OCF = sum(self.ACI_OCF * vars[f&#34;b({j})&#34;] for j in self.OCF)
        self.capex_MPF = sum(self.ACI_MPF * vars[f&#34;b({k})&#34;] for k in self.MPF)
        self.capex_CPF = sum(self.ACI_CPF * vars[f&#34;b({l})&#34;] for l in self.CPF)
        self.capex_DPF = sum(self.ACI_DPF * vars[f&#34;b({m})&#34;] for m in self.DPF)
        # OPEX of facilities int he value chain
        self.opex_OCF = sum(
            (
                self.fOPEX_OCF * vars[f&#34;b({j})&#34;]
                + self.vOPEX_OCF
                * sum(vars[f&#34;x({p},{i},{j})&#34;] for i in self.S for p in self.P)
            )
            for j in self.OCF
        )
        self.opex_MPF = sum(
            (
                self.fOPEX_MPF * vars[f&#34;b({k})&#34;]
                + self.vOPEX_MPF
                * sum(vars[f&#34;x({p},{j},{k})&#34;] for j in self.OCF for p in self.P)
            )
            for k in self.MPF
        )
        self.opex_CPF = sum(
            (
                self.fOPEX_CPF * vars[f&#34;b({l})&#34;]
                + self.vOPEX_CPF
                * sum(vars[f&#34;x({p},{k},{l})&#34;] for k in self.MPF for p in self.P)
            )
            for l in self.CPF
        )
        self.opex_DPF = sum(
            (
                self.fOPEX_DPF * vars[f&#34;b({m})&#34;]
                + self.vOPEX_DPF
                * sum(vars[f&#34;x({p},{l},{m})&#34;] for l in self.CPF for p in self.P)
            )
            for m in self.DPF
        )

        # compute individual elements of the environmental objective function
        # transportation impact between S and OCF
        self.transportation_impact_1 = sum(
            2
            * self.D1.loc[i, j]
            * self.TI_ETICS
            * sum(vars[f&#34;x({p},{i},{j})&#34;] for p in self.P)
            for i in self.S
            for j in self.OCF
        )
        # transportation impact between OCF and MPF
        self.transportation_impact_2 = sum(
            2
            * self.D2.loc[j, k]
            * self.TI_comp_ETICS
            * sum(vars[f&#34;x({p},{j},{k})&#34;] for p in self.P)
            for j in self.OCF
            for k in self.MPF
        )
        # transportation impact between MPF and CPF
        self.transportation_impact_3 = sum(
            2
            * self.D3.loc[k, l]
            * self.TI_pre_concentrate
            * sum(vars[f&#34;x({p},{k},{l})&#34;] for p in self.P)
            for k in self.MPF
            for l in self.CPF
        )
        # transportation impact between CPF and DPF
        self.transportation_impact_4 = sum(
            2
            * self.D4.loc[l, m]
            * self.TI_pyrolysis_oil
            * sum(vars[f&#34;x({p},{l},{m})&#34;] for p in self.P)
            for l in self.CPF
            for m in self.DPF
        )
        # transportation impact between DPF and C
        self.transportation_impact_5 = sum(
            2
            * self.D5.loc[m, n]
            * self.TI_styrene
            * sum(vars[f&#34;x({p},{m},{n})&#34;] for p in self.P)
            for m in self.DPF
            for n in self.C
        )
        # construction impact
        self.construction_impact_OCF = sum(
            self.CI_OCF * sum(vars[f&#34;x({p},{i},{j})&#34;] for i in self.S for p in self.P)
            for j in self.OCF
        )
        self.construction_impact_MPF = sum(
            self.CI_MPF * sum(vars[f&#34;x({p},{j},{k})&#34;] for j in self.OCF for p in self.P)
            for k in self.MPF
        )
        self.construction_impact_CPF = sum(
            self.CI_CPF * sum(vars[f&#34;x({p},{k},{l})&#34;] for k in self.MPF for p in self.P)
            for l in self.CPF
        )
        self.construction_impact_DPF = sum(
            self.CI_DPF * sum(vars[f&#34;x({p},{l},{m})&#34;] for l in self.CPF for p in self.P)
            for m in self.DPF
        )
        # operational impact
        self.operational_impact_OCF = sum(
            self.OI_OCF * sum(vars[f&#34;x({p},{i},{j})&#34;] for i in self.S for p in self.P)
            for j in self.OCF
        )
        self.operational_impact_MPF = sum(
            self.OI_MPF * sum(vars[f&#34;x({p},{j},{k})&#34;] for j in self.OCF for p in self.P)
            for k in self.MPF
        )
        self.operational_impact_CPF = sum(
            self.OI_CPF * sum(vars[f&#34;x({p},{k},{l})&#34;] for k in self.MPF for p in self.P)
            for l in self.CPF
        )
        self.operational_impact_DPF = sum(
            self.OI_DPF * sum(vars[f&#34;x({p},{l},{m})&#34;] for l in self.CPF for p in self.P)
            for m in self.DPF
        )

        # compute break-even price of styrene and the LCA&#39;s functional unit
        self.styrene_amount = sum(
            sum(vars[f&#34;x({p},{m},{n})&#34;] for m in self.DPF for p in self.P)
            for n in self.C
        )
        self.break_even_price = (
            abs(self.obj_economic - self.Revenue) / self.styrene_amount
        )
        self.functional_unit = (
            self.obj_environmental / self.env_cost / self.styrene_amount
        )
        print(f&#34;Amount of styrene produced: {self.styrene_amount:.2f} [ton]&#34;)
        print(
            f&#34;Break-even price of styrene: {self.break_even_price:.2f} [euro/ton of styrene]&#34;
        )
        print(
            f&#34;LCA functional unit: {self.functional_unit:.2f} [ton CO2eq/ton of styrene]&#34;
        )

    def plot_infrastructure(self, country=None, img_path=None):
        &#34;&#34;&#34;
        Create plot where the nodes are plotted as a scatter plot with the size
        of the node corresponding to the amount of waste sourced from it. The
        installed facilities (and the presence or lack of customers) is then
        indicated by icons which are used to annotate nodes on the plot.

        Parameters
        ----------
        country (str): optional string containing name of the considered country
        in english, used to obtain the country&#39;s centre and extremes (northmost
        southmost, eastmost, westmost) for setting plot limits

        img_path (str): optional string containing the location of the image
        file which (if specified) will be used as a background for the generated
        plot, REQUIRES ``country`` to be specified as well

        Notes
        -----
        This is a good way for visually inspecting and checking smaller
        networks.
        &#34;&#34;&#34;

        # convert source_cap DataFrame to list containing row sums
        source_cap_row_sums = self.source_cap.sum(axis=1).to_list()
        # extract source coordinates to list
        sources = pd.read_csv(&#34;results/coordinates_sources.csv&#34;)
        x_coords = sources[&#34;xcord&#34;].to_list()
        y_coords = sources[&#34;ycord&#34;].to_list()
        # extract customer coordinates list
        customers = pd.read_csv(&#34;results/coordinates_customers.csv&#34;)
        x_coords_c = customers[&#34;xcord&#34;].to_list()
        y_coords_c = customers[&#34;ycord&#34;].to_list()

        # obtain plot limits using geocoder if ``country`` is specified
        if country != None:
            # obtain corresponding lats and lngs using Nominatim geocoder
            centre = gc.get_country_coords(country)
            bounding_box = gc.get_country_coords(country, output_as=&#34;boundingbox&#34;)
            # calculate x and y distances to the bottom left and top right corners
            bottom_left = cc.coords_to_distances(
                (bounding_box[0], bounding_box[2]), (centre[0], centre[1])
            )
            top_right = cc.coords_to_distances(
                (bounding_box[1], bounding_box[3]), (centre[0], centre[1])
            )
            # extract the required extents for the plot
            x_min = bottom_left[0]
            x_max = top_right[0]
            y_min = bottom_left[1]
            y_max = top_right[1]
        # otherwise, obtain plot limits based on plotted data
        else:
            length_x = max(x_coords) - min(x_coords)
            length_y = max(y_coords) - min(y_coords)

        # convert name_list of installed facilities into an int_list
        int_list_OCF = name_list_to_int_list(self.name_list_OCF)
        int_list_MPF = name_list_to_int_list(self.name_list_MPF)
        int_list_CPF = name_list_to_int_list(self.name_list_CPF)
        int_list_DPF = name_list_to_int_list(self.name_list_DPF)

        # use source row sums to create scatter plot with scaled source size
        fig, ax = plt.subplots(figsize=(8, 8))
        factor = int(300 / max(source_cap_row_sums))
        size = [factor * val for val in source_cap_row_sums]
        ax.scatter(x_coords, y_coords, c=&#34;k&#34;, s=size, zorder=1)
        ax.set_xlabel(&#34;Horizontal distance [km]&#34;)
        ax.set_ylabel(&#34;Vertical distance [km]&#34;)
        # set corresponding limits to the plot
        if country != None:
            ax.set_xlim(x_min * 1.2, x_max * 1.2)
            ax.set_ylim(y_min * 1.2, y_max * 1.2)
        else:
            ax.set_xlim(min(x_coords) - length_x * 0.2, max(x_coords) + length_x * 0.2)
            ax.set_ylim(min(y_coords) - length_y * 0.2, max(y_coords) + length_y * 0.2)
        # set background image if ``img_path`` has been provided
        if img_path != None and country != None:
            background_img = plt.imread(img_path)
            ax.imshow(background_img, zorder=0, extent=[x_min, x_max, y_min, y_max])
        # chosen offset for annotation from the node
        offset = max(20, self.source_cap.values.max() / 60)
        # annotate nodes where OCFs have been installed
        imagebox = osb.OffsetImage(plt.imread(&#34;icons/OCF.png&#34;), zoom=0.03)
        for value in int_list_OCF:
            ab = osb.AnnotationBbox(
                imagebox,
                xy=(x_coords[value], y_coords[value]),
                xybox=(-offset, 0),
                frameon=False,
                boxcoords=&#34;offset points&#34;,
            )
            plt.gca().add_artist(ab)
        # annotate nodes where MPFs have been installed
        imagebox = osb.OffsetImage(plt.imread(&#34;icons/MPF.png&#34;), zoom=0.03)
        for value in int_list_MPF:
            ab = osb.AnnotationBbox(
                imagebox,
                xy=(x_coords[value], y_coords[value]),
                xybox=(-offset * math.sqrt(2) / 2, offset * math.sqrt(2) / 2),
                frameon=False,
                boxcoords=&#34;offset points&#34;,
            )
            plt.gca().add_artist(ab)
        # annnotate nodes where CPFs have been installed
        imagebox = osb.OffsetImage(plt.imread(&#34;icons/CPF.png&#34;), zoom=0.03)
        for value in int_list_CPF:
            ab = osb.AnnotationBbox(
                imagebox,
                xy=(x_coords[value], y_coords[value]),
                xybox=(0, offset),
                frameon=False,
                boxcoords=&#34;offset points&#34;,
            )
            plt.gca().add_artist(ab)
        # annotate nodes where DPFs have been installed
        imagebox = osb.OffsetImage(plt.imread(&#34;icons/DPF.png&#34;), zoom=0.03)
        for value in int_list_DPF:
            ab = osb.AnnotationBbox(
                imagebox,
                xy=(x_coords[value], y_coords[value]),
                xybox=(offset * math.sqrt(2) / 2, offset * math.sqrt(2) / 2),
                frameon=False,
                boxcoords=&#34;offset points&#34;,
            )
            plt.gca().add_artist(ab)
        # annotate nodes where customers are located
        imagebox = osb.OffsetImage(plt.imread(&#34;icons/C.png&#34;), zoom=0.03)
        for idx in range(0, len(x_coords_c)):
            ab = osb.AnnotationBbox(
                imagebox,
                xy=(x_coords_c[idx], y_coords_c[idx]),
                xybox=(offset, 0),
                frameon=False,
                boxcoords=&#34;offset points&#34;,
            )
            plt.gca().add_artist(ab)
        # set plot title
        plt.title(
            f&#34;SY break-even price: {self.break_even_price:_.2f} [euro/ton SY]\nLCA functional unit: {self.functional_unit:_.2f} [ton CO2eq/ton SY]&#34;.replace(
                &#34;_&#34;, &#34;&#39;&#34;
            )
        )
        fig.savefig(
            &#34;results/infrastructure.pdf&#34;, dpi=1200, bbox_inches=&#34;tight&#34;, pad_inches=0.1
        )

    def plot_product_flow(self, country=None, img_path=None, layered=False):
        &#34;&#34;&#34;
        Create a plot where product flows are plotted between nodes represented
        by a scatter plot. The nodes of the scatter plot are scaled according to
        the amount of waste available at them. Product interchange between nodes
        is represented by a line connecting them. The lines and nodes are colour
        and shape coded according to the facilities installed at the node and
        the type of material being transported.

        Parameters
        ----------
        country (str): optional string containing name of the considered country
        in english, used to obtain the country&#39;s centre and extremes (northmost
        southmost, eastmost, westmost) for setting plot limits

        img_path (str): optional string containing the location of the image
        file which (if specified) will be used as a background for the generated
        plot, REQUIRES ``country`` to be specified as well

        layered (bool): optional boolean which is False by default, if set to
        True then the default figure will be generated along with a series of
        figures where the product flow is separeted into layers by plotting each
        product flow type in a separate figure (the layered visualisation is
        useful for analysing complex or very large networks)

        Notes
        -----
        This is a good way for visually inspecting and checking larger networks.
        &#34;&#34;&#34;

        # define colour scheme used throughout using hex notation
        # colours correspond to: yellow, orange, red, purple, indigo
        colours = [&#34;#ffa600&#34;, &#34;#ff6361&#34;, &#34;#bc5090&#34;, &#34;#58508d&#34;, &#34;#003f5c&#34;]

        # convert source_cap DataFrame to list containing row sums
        source_cap_row_sums = self.source_cap.sum(axis=1).to_list()
        # extract source coordinates to list
        sources = pd.read_csv(&#34;results/coordinates_sources.csv&#34;)
        x_coords = sources[&#34;xcord&#34;].to_list()
        y_coords = sources[&#34;ycord&#34;].to_list()
        # convert name_list of installed facilities into an int_list
        int_list_OCF = name_list_to_int_list(self.name_list_OCF)
        int_list_MPF = name_list_to_int_list(self.name_list_MPF)
        int_list_CPF = name_list_to_int_list(self.name_list_CPF)
        int_list_DPF = name_list_to_int_list(self.name_list_DPF)
        # create manual symbols for legend
        point_S = mlines.Line2D(
            [0],
            [0],
            label=&#34;only S&#34;,
            marker=&#34;o&#34;,
            markersize=10,
            markeredgecolor=colours[0],
            markerfacecolor=colours[0],
            linestyle=&#34;&#34;,
        )
        point_OCF = mlines.Line2D(
            [0],
            [0],
            label=&#34;up to OCF&#34;,
            marker=&#34;o&#34;,
            markersize=10,
            markeredgecolor=colours[1],
            markerfacecolor=colours[1],
            linestyle=&#34;&#34;,
        )
        point_MPF = mlines.Line2D(
            [0],
            [0],
            label=&#34;up to MPF&#34;,
            marker=&#34;o&#34;,
            markersize=10,
            markeredgecolor=colours[2],
            markerfacecolor=colours[2],
            linestyle=&#34;&#34;,
        )
        point_CPF = mlines.Line2D(
            [0],
            [0],
            label=&#34;up to CPF&#34;,
            marker=&#34;o&#34;,
            markersize=10,
            markeredgecolor=colours[3],
            markerfacecolor=colours[3],
            linestyle=&#34;&#34;,
        )
        point_DPF = mlines.Line2D(
            [0],
            [0],
            label=&#34;up to DPF&#34;,
            marker=&#34;o&#34;,
            markersize=10,
            markeredgecolor=colours[4],
            markerfacecolor=colours[4],
            linestyle=&#34;&#34;,
        )
        line_ET = mlines.Line2D(
            [0],
            [0],
            label=&#34;ETICS flow&#34;,
            c=colours[0],
        )
        line_CE = mlines.Line2D(
            [0],
            [0],
            label=&#34;compressed ETICS flow&#34;,
            c=colours[1],
        )
        line_PC = mlines.Line2D(
            [0],
            [0],
            label=&#34;pre-concentrate flow&#34;,
            c=colours[2],
        )
        line_PO = mlines.Line2D(
            [0],
            [0],
            label=&#34;pyrolysis oil flow&#34;,
            c=colours[3],
        )
        line_PS = mlines.Line2D(
            [0],
            [0],
            label=&#34;styrene flow&#34;,
            c=colours[4],
        )
        # obtain plot limits using geocoder if ``country`` is specified
        if country != None:
            # obtain corresponding lats and lngs using Nominatim geocoder
            centre = gc.get_country_coords(country)
            bounding_box = gc.get_country_coords(country, output_as=&#34;boundingbox&#34;)
            # calculate x and y distances to the bottom left and top right corners
            bottom_left = cc.coords_to_distances(
                (bounding_box[0], bounding_box[2]), (centre[0], centre[1])
            )
            top_right = cc.coords_to_distances(
                (bounding_box[1], bounding_box[3]), (centre[0], centre[1])
            )
            # extract the required extents for the plot
            x_min = bottom_left[0]
            x_max = top_right[0]
            y_min = bottom_left[1]
            y_max = top_right[1]
        # otherwise, obtain plot limits based on plotted data
        else:
            length_x = max(x_coords) - min(x_coords)
            length_y = max(y_coords) - min(y_coords)

        # create the default unlayered figure
        fig, ax = plt.subplots(figsize=(8, 8))
        ax.set_xlabel(&#34;Horizontal distance [km]&#34;)
        ax.set_ylabel(&#34;Vertical distance [km]&#34;)
        # set corresponding limits to the plot
        if country != None:
            ax.set_xlim(x_min * 1.2, x_max * 1.2)
            ax.set_ylim(y_min * 1.2, y_max * 1.5)
        else:
            ax.set_xlim(min(x_coords) - length_x * 0.2, max(x_coords) + length_x * 0.2)
            ax.set_ylim(min(y_coords) - length_y * 0.2, max(y_coords) + length_y * 0.5)
        # set background image if ``img_path`` has been provided
        if img_path != None and country != None:
            background_img = plt.imread(img_path)
            ax.imshow(background_img, zorder=0, extent=[x_min, x_max, y_min, y_max])
        # loop over the source coordinates (that is, number of nodes)
        factor = int(300 / max(source_cap_row_sums))
        for idx in range(0, len(x_coords)):
            # plot node with select node colour
            if idx in int_list_DPF:
                colour = colours[4]
            elif idx in int_list_CPF:
                colour = colours[3]
            elif idx in int_list_MPF:
                colour = colours[2]
            elif idx in int_list_OCF:
                colour = colours[1]
            else:
                colour = colours[0]
            # plot the node
            plt.scatter(
                x_coords[idx],
                y_coords[idx],
                c=colour,
                s=source_cap_row_sums[idx] * factor,
                zorder=2.5,
            )
        # draw lines representing exchanged products
        product_flows = pd.read_csv(&#34;results/product_flow.csv&#34;)
        for _, row in product_flows.iterrows():
            origin_int = name_to_int(row[&#34;Origin&#34;])
            destination_int = name_to_int(row[&#34;Destination&#34;])
            # draw line only if origin and destination have different node num.
            if origin_int != destination_int:
                # plot line with selected product flow colour
                if row[&#34;Product&#34;] == &#34;ETICS&#34;:
                    colour = colours[0]
                elif row[&#34;Product&#34;] == &#34;compressed_ETICS&#34;:
                    colour = colours[1]
                elif row[&#34;Product&#34;] == &#34;pre_concentrate&#34;:
                    colour = colours[2]
                elif row[&#34;Product&#34;] == &#34;pyrolysis_oil&#34;:
                    colour = colours[3]
                else:
                    colour = colours[4]
                # draw the corresponding product flow line
                x = (x_coords[origin_int], x_coords[destination_int])
                y = (y_coords[origin_int], y_coords[destination_int])
                plt.plot(x, y, lw=2, c=colour)
                # annotate the line with an arrow showing flow direction
                x_diff = x_coords[destination_int] - x_coords[origin_int]
                y_diff = y_coords[destination_int] - y_coords[origin_int]
                plt.annotate(
                    &#34;&#34;,
                    xy=(
                        x_coords[origin_int] + 0.8 * x_diff,
                        y_coords[origin_int] + 0.8 * y_diff,
                    ),
                    xytext=(
                        x_coords[origin_int] + 0.6 * x_diff,
                        y_coords[origin_int] + 0.6 * y_diff,
                    ),
                    arrowprops=dict(
                        arrowstyle=&#34;-&gt;&#34;, lw=2, color=colour, mutation_scale=25
                    ),
                    zorder=1,
                )
        plt.legend(
            handles=[
                point_S,
                point_OCF,
                point_MPF,
                point_CPF,
                point_DPF,
                line_ET,
                line_CE,
                line_PC,
                line_PO,
                line_PS,
            ],
            loc=&#34;upper right&#34;,
            ncol=2,
            frameon=False,
        )
        plt.title(
            f&#34;SY break-even price: {self.break_even_price:_.2f} [euro/ton SY]\nLCA functional unit: {self.functional_unit:_.2f} [ton CO2eq/ton SY]&#34;.replace(
                &#34;_&#34;, &#34;&#39;&#34;
            )
        )
        fig.savefig(
            &#34;results/product_flow.pdf&#34;, dpi=1200, bbox_inches=&#34;tight&#34;, pad_inches=0.1
        )

        # create layered figure if specified
        if layered:
            # loop over the number of layers required &amp; clear existing figure
            plt.clf()
            for layer in range(0, len(colours)):
                fig, ax = plt.subplots(figsize=(8, 8))
                ax.set_xlabel(&#34;Horizontal distance [km]&#34;)
                ax.set_ylabel(&#34;Vertical distance [km]&#34;)
                # set corresponding limits to the plot
                if country != None:
                    ax.set_xlim(x_min * 1.2, x_max * 1.2)
                    ax.set_ylim(y_min * 1.2, y_max * 1.5)
                else:
                    ax.set_xlim(
                        min(x_coords) - length_x * 0.2, max(x_coords) + length_x * 0.2
                    )
                    ax.set_ylim(
                        min(y_coords) - length_y * 0.2, max(y_coords) + length_y * 0.5
                    )
                # set background image if ``img_path`` has been provided
                if img_path != None and country != None:
                    background_img = plt.imread(img_path)
                    ax.imshow(
                        background_img, zorder=0, extent=[x_min, x_max, y_min, y_max]
                    )
                # loop over the source coordinates (that is, number of nodes)
                # create a scatter plont of all nodes
                factor = int(300 / max(source_cap_row_sums))
                for idx in range(0, len(x_coords)):
                    # plot node with select node colour
                    if idx in int_list_DPF:
                        colour = colours[4]
                    elif idx in int_list_CPF:
                        colour = colours[3]
                    elif idx in int_list_MPF:
                        colour = colours[2]
                    elif idx in int_list_OCF:
                        colour = colours[1]
                    else:
                        colour = colours[0]
                    # plot the node
                    plt.scatter(
                        x_coords[idx],
                        y_coords[idx],
                        c=colour,
                        s=source_cap_row_sums[idx] * factor,
                        zorder=2.5,
                    )
                # draw lines representing product flow ONLY on current layer
                product_flows = pd.read_csv(&#34;results/product_flow.csv&#34;)
                title = f&#34;Layer: {self.P[layer]} flow&#34;.replace(&#34;_&#34;, &#34; &#34;)
                for _, row in product_flows.iterrows():
                    origin_int = name_to_int(row[&#34;Origin&#34;])
                    destination_int = name_to_int(row[&#34;Destination&#34;])
                    # draw line only if origin &amp; destination have diff node num.
                    if origin_int != destination_int:
                        # plot lines only if they should appear on current layer
                        if self.P.index(row[&#34;Product&#34;]) == layer:
                            colour = colours[layer]
                            # draw the corresponding product flow line
                            x = (x_coords[origin_int], x_coords[destination_int])
                            y = (y_coords[origin_int], y_coords[destination_int])
                            plt.plot(x, y, lw=2, c=colour)
                            # annotate w arrow showing flow direction
                            x_diff = x_coords[destination_int] - x_coords[origin_int]
                            y_diff = y_coords[destination_int] - y_coords[origin_int]
                            plt.annotate(
                                &#34;&#34;,
                                xy=(
                                    x_coords[origin_int] + 0.8 * x_diff,
                                    y_coords[origin_int] + 0.8 * y_diff,
                                ),
                                xytext=(
                                    x_coords[origin_int] + 0.6 * x_diff,
                                    y_coords[origin_int] + 0.6 * y_diff,
                                ),
                                arrowprops=dict(
                                    arrowstyle=&#34;-&gt;&#34;,
                                    lw=2,
                                    color=colour,
                                    mutation_scale=25,
                                ),
                                zorder=1,
                            )
                        else:
                            continue
                # finish annotating figure and save it
                plt.legend(
                    handles=[
                        point_S,
                        point_OCF,
                        point_MPF,
                        point_CPF,
                        point_DPF,
                        line_ET,
                        line_CE,
                        line_PC,
                        line_PO,
                        line_PS,
                    ],
                    loc=&#34;upper right&#34;,
                    ncol=2,
                    frameon=False,
                )
                plt.title(title)
                file_name = f&#34;results/product_flow_layer{layer}.pdf&#34;
                fig.savefig(file_name, dpi=1200, bbox_inches=&#34;tight&#34;, pad_inches=0.1)

    def plot_objective_function_breakdown(self):
        &#34;&#34;&#34;
        Function for plotting a bar graph where the individual components of
        both the economic and environmental objective functions are broken down.
        The plot generates an individual subplot for each of the objective
        functions.

        Notes
        -----
        This is an excellent method for comparing where the costs and
        environmental impacts occur in different networks.
        &#34;&#34;&#34;

        # define colour scheme used throughout using hex notation
        # colours correspond to: yellow, orange, red, purple, indigo
        colours = [&#34;#ffa600&#34;, &#34;#ff6361&#34;, &#34;#bc5090&#34;, &#34;#58508d&#34;, &#34;#003f5c&#34;]

        # define number of categories
        N = 3

        # clear the figure
        plt.clf()
        # configure figure fonts
        plt.rcParams[&#34;font.size&#34;] = 16

        # define economic subcategories and their values
        ETICS = (self.transportation_cost_1, 0, 0)
        compressed_ETICS = (
            self.transportation_cost_2,
            self.capex_OCF,
            self.opex_OCF,
        )
        pre_concentrate = (
            self.transportation_cost_3,
            self.capex_MPF,
            self.opex_MPF,
        )
        pyrolysis_oil = (
            self.transportation_cost_4,
            self.capex_CPF,
            self.opex_CPF,
        )
        styrene = (
            self.transportation_cost_5,
            self.capex_DPF,
            self.opex_DPF,
        )

        # define the bottoms using numpy to add the tuples
        bottom3 = np.add(np.array(ETICS), np.array(compressed_ETICS))
        bottom4 = np.add(np.array(bottom3), np.array(pre_concentrate))
        bottom5 = np.add(np.array(bottom4), np.array(pyrolysis_oil))

        # plot the bar graphs for the economic values and save the figure
        ind = np.arange(N)
        width = 0.65
        fig, ax = plt.subplots(figsize=(8, 8))
        b1 = ax.bar(ind, ETICS, width, color=colours[0])
        b2 = ax.bar(ind, compressed_ETICS, width, bottom=ETICS, color=colours[1])
        b3 = ax.bar(
            ind,
            pre_concentrate,
            width,
            bottom=bottom3,
            color=colours[2],
        )
        b4 = ax.bar(
            ind,
            pyrolysis_oil,
            width,
            bottom=bottom4,
            color=colours[3],
        )
        b5 = ax.bar(
            ind,
            styrene,
            width,
            bottom=bottom5,
            color=colours[4],
        )
        ax.set_ylabel(&#34;Economic cost [euro/day]&#34;)
        ax.set_xticks(ind, (&#34;TC&#34;, &#34;CAPEX&#34;, &#34;OPEX&#34;))
        ax.legend(
            (b1[0], b2[0], b3[0], b4[0], b5[0]),
            (
                &#34;ET&#34;,
                &#34;CE or OCF&#34;,
                &#34;PC or MPF&#34;,
                &#34;PO or CPF&#34;,
                &#34;SY or DPF&#34;,
            ),
            loc=&#34;upper left&#34;,
        )
        ax.set_title(
            f&#34;Total economic cost: {abs(self.obj_economic - self.Revenue):_.2f} euro/day&#34;.replace(
                &#34;_&#34;, &#34;&#39;&#34;
            )
        )
        fig.savefig(
            &#34;results/economic_objective_breakdown.pdf&#34;,
            dpi=1200,
            bbox_inches=&#34;tight&#34;,
            pad_inches=0.1,
        )

        # clear the figure
        plt.clf()

        # define environmental subcategories and their values
        ETICS = (float(self.transportation_impact_1), float(0), float(0))
        compressed_ETICS = (
            self.transportation_impact_2,
            self.construction_impact_OCF,
            self.operational_impact_OCF,
        )
        pre_concentrate = (
            self.transportation_impact_3,
            self.construction_impact_MPF,
            self.operational_impact_MPF,
        )
        pyrolysis_oil = (
            self.transportation_impact_4,
            self.construction_impact_CPF,
            self.operational_impact_CPF,
        )
        styrene = (
            self.transportation_impact_5,
            self.construction_impact_DPF,
            self.operational_impact_DPF,
        )

        # define the bottoms using numpy to add the tuples
        bottom3 = np.add(np.array(ETICS), np.array(compressed_ETICS))
        bottom4 = np.add(np.array(bottom3), np.array(pre_concentrate))
        bottom5 = np.add(np.array(bottom4), np.array(pyrolysis_oil))

        # plot the bar graphs for the environmental values and save the figure
        ind = np.arange(N)
        width = 0.65
        fig, ax = plt.subplots(figsize=(8, 8))
        b1 = ax.bar(ind, ETICS, width, color=colours[0])
        b2 = ax.bar(ind, compressed_ETICS, width, bottom=ETICS, color=colours[1])
        b3 = ax.bar(
            ind,
            pre_concentrate,
            width,
            bottom=bottom3,
            color=colours[2],
        )
        b4 = ax.bar(
            ind,
            pyrolysis_oil,
            width,
            bottom=bottom4,
            color=colours[3],
        )
        b5 = ax.bar(
            ind,
            styrene,
            width,
            bottom=bottom5,
            color=colours[4],
        )
        ax.set_ylabel(&#34;Environmental impact [tons CO2-eq/day]&#34;)
        ax.set_xticks(ind, (&#34;TI&#34;, &#34;CI&#34;, &#34;OI&#34;))
        ax.legend(
            (b1[0], b2[0], b3[0], b4[0], b5[0]),
            (
                &#34;ET&#34;,
                &#34;CE or OCF&#34;,
                &#34;PC or MPF&#34;,
                &#34;PO or CPF&#34;,
                &#34;SY or DPF&#34;,
            ),
            loc=&#34;upper left&#34;,
        )
        ax.set_title(
            f&#34;Total environmental impact: {self.obj_environmental/self.env_cost:_.2f} tons CO2-eq/day&#34;.replace(
                &#34;_&#34;, &#34;&#39;&#34;
            )
        )
        fig.savefig(
            &#34;results/environmental_objective_breakdown.pdf&#34;,
            dpi=1200,
            bbox_inches=&#34;tight&#34;,
            pad_inches=0.1,
        )

    def tabulate_product_flows(self):
        &#34;&#34;&#34;
        Generate a table with the facility types as columns and the node numbers
        as rows. The cells are populated with the amount of product flowing
        through a specific type of facility in a specific node [tons/day], along
        with the number of facilities installed and their capacity in
        parenthesis. Two tables are generated from the results: one through
        creating a tex file and callind pdflatex, and one using Seaborn which
        displays only teh values (not the number of installed facilities).
        &#34;&#34;&#34;

        # extract resulting variable values and store them in a dictionary
        vars = {}
        for var in self.model.getVars():
            vars[f&#34;{var.varName}&#34;] = var.x

        # read the product_flow csv using pandas
        product_flows = pd.read_csv(&#34;results/product_flow.csv&#34;)

        # generate a pandas dataframe for the tabulation
        columns = [&#34;OCF [ton/day]&#34;, &#34;MPF [ton/day]&#34;, &#34;CPF [ton/day]&#34;, &#34;DPF [ton/day]&#34;]
        tabulated_product_flow = pd.DataFrame(columns=columns)
        tabulated_product_flow.rename_axis(&#34;node&#34;, axis=1)
        # generate another dataframe which will store only the values
        tabulated_product_flow_val = pd.DataFrame(columns=columns)
        tabulated_product_flow_val.rename_axis(&#34;node&#34;, axis=1)

        # loop over the nodes in the network
        sources = pd.read_csv(&#34;results/coordinates_sources.csv&#34;)
        x_coords = sources[&#34;xcord&#34;].to_list()
        for node in range(0, len(x_coords)):
            # filter the df using OCF &amp; current node, then extract info
            name = f&#34;OCF_{node}&#34;
            OCF_amount = 0
            filtered = product_flows[product_flows[&#34;Destination&#34;] == name]
            for _, row in filtered.iterrows():
                OCF_amount += row[&#34;Amount&#34;]
            OCF_installed = abs(vars[f&#34;b({name})&#34;])
            OCF_entry = f&#34;{OCF_amount:.1f} ({OCF_installed:.0f} * {self.facility_cap[&#39;OCF&#39;]:.1f})&#34;
            OCF_entry_val = OCF_amount

            # filter the df using MPF &amp; current node, then extract info
            name = f&#34;MPF_{node}&#34;
            MPF_amount = 0
            filtered = product_flows[product_flows[&#34;Destination&#34;] == name]
            for _, row in filtered.iterrows():
                MPF_amount += row[&#34;Amount&#34;]
            MPF_installed = abs(vars[f&#34;b({name})&#34;])
            MPF_entry = f&#34;{MPF_amount:.1f} ({MPF_installed:.0f} * {self.facility_cap[&#39;MPF&#39;]:.1f})&#34;
            MPF_entry_val = MPF_amount

            # filter the df using CPF &amp; current node, then extract info
            name = f&#34;CPF_{node}&#34;
            CPF_amount = 0
            filtered = product_flows[product_flows[&#34;Destination&#34;] == name]
            for _, row in filtered.iterrows():
                CPF_amount += row[&#34;Amount&#34;]
            CPF_installed = abs(vars[f&#34;b({name})&#34;])
            CPF_entry = f&#34;{CPF_amount:.1f} ({CPF_installed:.0f} * {self.facility_cap[&#39;CPF&#39;]:.1f})&#34;
            CPF_entry_val = CPF_amount

            # filter the df using DPF &amp; current node, then extract info
            name = f&#34;DPF_{node}&#34;
            DPF_amount = 0
            filtered = product_flows[product_flows[&#34;Destination&#34;] == name]
            for _, row in filtered.iterrows():
                DPF_amount += row[&#34;Amount&#34;]
            DPF_installed = abs(vars[f&#34;b({name})&#34;])
            DPF_entry = f&#34;{DPF_amount:.1f} ({DPF_installed:.0f} * {self.facility_cap[&#39;DPF&#39;]:.1f})&#34;
            DPF_entry_val = DPF_amount

            # construct new data for this node and append it to the dataframe
            new_data = {
                &#34;OCF [ton/day]&#34;: OCF_entry,
                &#34;MPF [ton/day]&#34;: MPF_entry,
                &#34;CPF [ton/day]&#34;: CPF_entry,
                &#34;DPF [ton/day]&#34;: DPF_entry,
            }
            tabulated_product_flow = tabulated_product_flow._append(
                new_data, ignore_index=True
            )
            # do the same for the dataframe containing only the values
            new_data_val = {
                &#34;OCF [ton/day]&#34;: OCF_entry_val,
                &#34;MPF [ton/day]&#34;: MPF_entry_val,
                &#34;CPF [ton/day]&#34;: CPF_entry_val,
                &#34;DPF [ton/day]&#34;: DPF_entry_val,
            }
            tabulated_product_flow_val = tabulated_product_flow_val._append(
                new_data_val, ignore_index=True
            )

        # name index columns of both dataframes
        tabulated_product_flow.index.name = &#34;node&#34;
        tabulated_product_flow_val.index.name = &#34;node&#34;

        # save the dataframe as a table in pdf format using latex
        filename = &#34;results/tabulated_product_flow.tex&#34;
        directory = &#34;results/&#34;
        template = r&#34;&#34;&#34;\documentclass[preview]{{standalone}}
        \usepackage{{booktabs}}
        \begin{{document}}
        {}
        \end{{document}}
        &#34;&#34;&#34;
        with open(filename, &#34;w&#34;) as f:
            f.write(template.format(tabulated_product_flow.to_latex()))
        # subprocess.call([&#34;pdflatex&#34;, filename])
        subprocess.run(
            [&#34;pdflatex&#34;, &#34;-output-directory=&#34; + directory, filename],
            stdout=subprocess.PIPE,
        )
        # generate Seaborn heatmap
        plt.clf()
        sns.heatmap(
            tabulated_product_flow_val,
            annot=True,
            cmap=&#34;Reds&#34;,
            yticklabels=tabulated_product_flow_val.index[::-1],
        )
        plt.savefig(
            &#34;results/tabulated_product_flow_heatmap.pdf&#34;,
            dpi=1200,
            bbox_inches=&#34;tight&#34;,
            pad_inches=0.1,
        )


@staticmethod
def six_tenths_rule(reference_capacity, target_capacity, reference_cost):
    &#34;&#34;&#34;
    Apply the six-tenths rule to approximate the cost ``target_cost`` for a
    ``target_capacity`` using known ``reference_cost`` for a
    ``reference_capacity``. The function is only reliable if the
    ``target_capacity`` and ``reference_capacity`` differ by a factor which is
    smaller than 10.

    Parameters
    ----------
    reference_capacity (float): capacity of the facility being used as a
    reference [ton/day]

    target_capacity (float): capacity of the upscaledd or downscaled facility
    for which we want to determine the CAPEX [ton/day]

    reference_cost (float): cost of the reference facility [Meuro]

    Returns
    -------
    target_cost (float): cost of the upscaled or downscaled facility [Meuro]

    NOTE: The function will exit the code instance and print a warning to the
    user in the case that it is being used within a range where the method is no
    longer considered to provide a reliable approximation.
    &#34;&#34;&#34;

    ratio = reference_capacity / target_capacity

    if ratio &gt; 10 or ratio &lt; 0.1:
        print(
            f&#34;WARNING: You are using the six-tenths rule to scale-up or scale-down cost for capacities that differ by a factor of {ratio:.2f}. This method cannot be used beyond a factor of 10.&#34;
        )
        sys.exit()

    target_cost = reference_cost * (target_capacity / reference_capacity) ** 0.6

    return target_cost


@staticmethod
def name_list_to_int_list(name_list):
    &#34;&#34;&#34;
    Use regular expressions to extract list of integers from a list of strings
    containing names of facilities that were installed, contained within
    ``name_list``.

    Parameters
    ----------
    name_list (list): list of strings representing installed facilities

    Returns
    -------
    int_list (list): list containing only integers in the provided strings
    &#34;&#34;&#34;

    # use regular expressions to extract only the numbers in the strings
    int_list = []
    for name in name_list:
        integer = int(re.search(r&#34;\d+&#34;, name).group())
        int_list.append(integer)

    return int_list


@staticmethod
def name_to_int(name):
    &#34;&#34;&#34;
    Use regular expressions to extract an integer from a string representing the
    name of an installed facility contained within ``name``.

    Parameters
    ----------
    name (string): string containing name of installed facility

    Returns
    -------
    integer (int): integer extracted from string representing facility name
    &#34;&#34;&#34;

    integer = int(re.search(r&#34;\d+&#34;, name).group())

    return integer</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="OptimisedWasteNetworksPy.src.optimisation.name_list_to_int_list"><code class="name flex">
<span>def <span class="ident">name_list_to_int_list</span></span>(<span>name_list)</span>
</code></dt>
<dd>
<div class="desc"><p>Use regular expressions to extract list of integers from a list of strings
containing names of facilities that were installed, contained within
<code>name_list</code>.</p>
<h2 id="parameters">Parameters</h2>
<p>name_list (list): list of strings representing installed facilities</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int_list (list): list containing only integers in the provided strings</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def name_list_to_int_list(name_list):
    &#34;&#34;&#34;
    Use regular expressions to extract list of integers from a list of strings
    containing names of facilities that were installed, contained within
    ``name_list``.

    Parameters
    ----------
    name_list (list): list of strings representing installed facilities

    Returns
    -------
    int_list (list): list containing only integers in the provided strings
    &#34;&#34;&#34;

    # use regular expressions to extract only the numbers in the strings
    int_list = []
    for name in name_list:
        integer = int(re.search(r&#34;\d+&#34;, name).group())
        int_list.append(integer)

    return int_list</code></pre>
</details>
</dd>
<dt id="OptimisedWasteNetworksPy.src.optimisation.name_to_int"><code class="name flex">
<span>def <span class="ident">name_to_int</span></span>(<span>name)</span>
</code></dt>
<dd>
<div class="desc"><p>Use regular expressions to extract an integer from a string representing the
name of an installed facility contained within <code>name</code>.</p>
<h2 id="parameters">Parameters</h2>
<p>name (string): string containing name of installed facility</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>integer (int): integer extracted from string representing facility name</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def name_to_int(name):
    &#34;&#34;&#34;
    Use regular expressions to extract an integer from a string representing the
    name of an installed facility contained within ``name``.

    Parameters
    ----------
    name (string): string containing name of installed facility

    Returns
    -------
    integer (int): integer extracted from string representing facility name
    &#34;&#34;&#34;

    integer = int(re.search(r&#34;\d+&#34;, name).group())

    return integer</code></pre>
</details>
</dd>
<dt id="OptimisedWasteNetworksPy.src.optimisation.six_tenths_rule"><code class="name flex">
<span>def <span class="ident">six_tenths_rule</span></span>(<span>reference_capacity, target_capacity, reference_cost)</span>
</code></dt>
<dd>
<div class="desc"><p>Apply the six-tenths rule to approximate the cost <code>target_cost</code> for a
<code>target_capacity</code> using known <code>reference_cost</code> for a
<code>reference_capacity</code>. The function is only reliable if the
<code>target_capacity</code> and <code>reference_capacity</code> differ by a factor which is
smaller than 10.</p>
<h2 id="parameters">Parameters</h2>
<p>reference_capacity (float): capacity of the facility being used as a
reference [ton/day]</p>
<p>target_capacity (float): capacity of the upscaledd or downscaled facility
for which we want to determine the CAPEX [ton/day]</p>
<p>reference_cost (float): cost of the reference facility [Meuro]</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>target_cost (float): cost</code> of <code>the upscaled</code> or <code>downscaled facility [Meuro]</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>NOTE</code></strong> :&ensp;<code>The function will exit the code instance and print a warning to the</code></dt>
<dd>&nbsp;</dd>
<dt><code>user in the case that it is being used within a range where the method is no</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>longer considered to provide a reliable approximation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def six_tenths_rule(reference_capacity, target_capacity, reference_cost):
    &#34;&#34;&#34;
    Apply the six-tenths rule to approximate the cost ``target_cost`` for a
    ``target_capacity`` using known ``reference_cost`` for a
    ``reference_capacity``. The function is only reliable if the
    ``target_capacity`` and ``reference_capacity`` differ by a factor which is
    smaller than 10.

    Parameters
    ----------
    reference_capacity (float): capacity of the facility being used as a
    reference [ton/day]

    target_capacity (float): capacity of the upscaledd or downscaled facility
    for which we want to determine the CAPEX [ton/day]

    reference_cost (float): cost of the reference facility [Meuro]

    Returns
    -------
    target_cost (float): cost of the upscaled or downscaled facility [Meuro]

    NOTE: The function will exit the code instance and print a warning to the
    user in the case that it is being used within a range where the method is no
    longer considered to provide a reliable approximation.
    &#34;&#34;&#34;

    ratio = reference_capacity / target_capacity

    if ratio &gt; 10 or ratio &lt; 0.1:
        print(
            f&#34;WARNING: You are using the six-tenths rule to scale-up or scale-down cost for capacities that differ by a factor of {ratio:.2f}. This method cannot be used beyond a factor of 10.&#34;
        )
        sys.exit()

    target_cost = reference_cost * (target_capacity / reference_capacity) ** 0.6

    return target_cost</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="OptimisedWasteNetworksPy.src.optimisation.Infrastructure"><code class="flex name class">
<span>class <span class="ident">Infrastructure</span></span>
<span>(</span><span>D1, D2, D3, D4, D5)</span>
</code></dt>
<dd>
<div class="desc"><p><code><a title="OptimisedWasteNetworksPy.src.optimisation.Infrastructure" href="#OptimisedWasteNetworksPy.src.optimisation.Infrastructure">Infrastructure</a> class</code> defines value-chain-specific parameters and builds
up the optimisation problem utilising pyscipopt</p>
<p>Initialise <code><a title="OptimisedWasteNetworksPy.src.optimisation.Infrastructure" href="#OptimisedWasteNetworksPy.src.optimisation.Infrastructure">Infrastructure</a></code> object utilising DataFrames for the
distance between facilities in the network.</p>
<h2 id="parameters">Parameters</h2>
<p>D1 (DataFrame): distance matrix for S to OCF</p>
<p>D2 (DataFrame): distance matrix for OCF to MPF</p>
<p>D3 (DataFrame): distance matrix for MPF to CPF</p>
<p>D4 (DataFrame): distance matrix for CPF to DPF</p>
<p>D5 (DataFrame): distance matrix for DPF to C</p>
<h2 id="notes">Notes</h2>
<p>User should be careful in naming facilities. Identical names cannot be
used to name different facilities at the same location. For example, a
source and collection facility in Cologne should have different names:
S_Cologne and OCF_Cologne, for example.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Infrastructure:
    &#34;&#34;&#34;
    ``Infrastructure class`` defines value-chain-specific parameters and builds
    up the optimisation problem utilising pyscipopt
    &#34;&#34;&#34;

    # define miscellaneous simulation variables
    env_cost = 170  # cost of the environmental impact [euro/ton CO2e]
    circuit_factor = 1.32  # average circuit factor for Germany []
    working_days = 330  # assume operation 330 day/year (7&#39;920h total) [days]
    # define transportation variables
    rolloff_load = 6  # maximum load for a roll-off [tons]
    rolloff_volume = 33  # maximum volume for a roll-off [m^3]
    tanker_volume = 45  # maximum volume for steel tanker [m^3]
    fuel_cons = 0.4  # fuel consumption [lt/km]
    fuel_price = 1.79  # fuel price [euro/lt]
    toll_cost = 0.198  # toll cost [euro/km]
    avg_speed = 60  # average driving speed [km/h]
    driver_wage = 45500  # driver wage [euro/year]
    driver_hours = 2070  # driver working hours [hours/year]
    vehicle_cost_rollof = 10000 / (15 * 360 * 90 / 14)  # roll-off [euro/h]
    vehicle_cost_tanker = 50000 / (15 * 360 * 90 / 14)  # steel tanker [euro/h]
    max_time = 100  # maximum transportation between facilities [hours]
    # define product physical variables
    rho_ETICS = 0.014  # density of ETICS [ton/m^3]
    rho_compressed_ETICS = 0.14  # density of compressed ETICS [ton/m^3]
    rho_pre_concentrate = 0.35  # density of pre-concentrate [ton/m^3]
    rho_pyrolysis_oil = 0.80  # density of pyrolysis oil [ton/m^3]
    rho_styrene = 0.910  # density of styrene [ton/m^3]
    # define economic variables
    ref_CAPEX_OCF = 0.057  # CAPEX of OCF for reference capacity [Meuro]
    ref_CAPEX_MPF = 8.0  # CAPEX of MPF for reference capacity [Meuro]
    ref_CAPEX_CPF = 10.11  # CAPEX of CPF for reference capacity [Meuro]
    ref_CAPEX_DPF = 5.17  # CAPEX of DPF for reference capacity [Meuro]
    ref_capacity_OCF = 140 / working_days  # OCF reference capacity [ton/day]
    ref_capacity_MPF = 15000 / working_days  # MPF reference capacity [ton/day]
    ref_capacity_CPF = 3960 / working_days  # CPF reference capacity [ton/day]
    ref_capacity_DPF = 14850 / working_days  # DPF reference capacity [ton/day]
    ref_fOPEX_OCF = 0.012  # reference fixed OPEX of OCF [Meuro/year]
    ref_fOPEX_MPF = 1.1  # reference fixed OPEX of MPF [Meuro/year]
    ref_fOPEX_CPF = 1.21  # reference fixed OPEX of CPF [Meuro/year]
    ref_fOPEX_DPF = 0.62  # reference fixed OPEX of DPF [Meuro/year]
    vOPEX_OCF = 11  # variable OPEX of OCF [euro/ton]
    vOPEX_MPF = 46  # variable OPEX of MPF [euro/ton]
    vOPEX_CPF = 108.68  # variable OPEX of CPF [euro/ton]
    vOPEX_DPF = 57.77  # variable OPEX of DPF [euro/ton]
    period = 10  # loan period [years]
    rate = 0.10  # discount rate []
    # define environmental impact variables
    env_rolloff = 5.6402e-4  # environmental impact of roll-off [tons CO2e/km]
    env_tanker = 1.0586e-4  # environmental impact of tanker [tons CO2e/km]
    CI_OCF = 2.808e-5  # construction impact of mech. plant [tons CO2e/ton]
    CI_MPF = 4.303e-3  # construction impact of mech. plant [tons CO2e/ton]
    CI_CPF = 0.816  # construction impact of chem. plant [tons CO2e/ton]
    CI_DPF = 0.218  # construction impact of chem. plant [tons CO2e/ton]
    OI_OCF = 1.250e-2  # operational impact of OCF [tons CO2e/ton]
    OI_MPF = 3.575e-2  # operational impact of MPF [tons CO2e/ton]
    OI_CPF = 0.524  # operational impact of CPF [tons CO2e/ton]
    OI_DPF = 1.156  # operational impact of DPF [tons CO2e/ton]

    def __init__(self, D1, D2, D3, D4, D5):
        &#34;&#34;&#34;
        Initialise ``Infrastructure`` object utilising DataFrames for the
        distance between facilities in the network.

        Parameters
        ----------
        D1 (DataFrame): distance matrix for S to OCF

        D2 (DataFrame): distance matrix for OCF to MPF

        D3 (DataFrame): distance matrix for MPF to CPF

        D4 (DataFrame): distance matrix for CPF to DPF

        D5 (DataFrame): distance matrix for DPF to C

        Notes
        -----
        User should be careful in naming facilities. Identical names cannot be
        used to name different facilities at the same location. For example, a
        source and collection facility in Cologne should have different names:
        S_Cologne and OCF_Cologne, for example.
        &#34;&#34;&#34;

        # initialise instance variables for distance matrices NOTE: multiplied
        # by circuit factor, only needed if use straight-line distance as is
        # currently being used
        self.D1 = D1 * self.circuit_factor
        self.D2 = D2 * self.circuit_factor
        self.D3 = D3 * self.circuit_factor
        self.D4 = D4 * self.circuit_factor
        self.D5 = D5 * self.circuit_factor
        # initialise instance variables for sources, customers &amp; facilities
        self.S = D1.index.tolist()
        self.OCF = D1.columns.tolist()
        self.MPF = D3.index.tolist()
        self.CPF = D3.columns.tolist()
        self.DPF = D5.index.tolist()
        self.C = D5.columns.tolist()

    def define_value_chain(
        self,
        products,
        source_capacity,
        facility_capacity,
        demand,
        yield_factor,
        market_price,
    ):
        &#34;&#34;&#34;
        Define the value chain by specifying product- and capacity-specific
        parameters.

        Parameters
        ----------
        products (list): contains names of products in value chain

        source_capacity (DataFrame): contains source capacities [tons]

        facility_capacity (dict): contains facilities as keys and capacities as
        values [tons]

        demand (list): contains demand of all products [tons]

        yield_factor (dict): contains product and facility type as keys and
        corresponding yield factors as values

        market_price (dict): contains products as keys and market price as
        values [euro/ton]
        &#34;&#34;&#34;

        # initialise instance variables from provided parameters
        self.P = products
        self.PP = products  # P subset used when products transformed @ facility
        self.source_cap = source_capacity
        self.yield_factor = yield_factor
        self.market_price = market_price
        self.facility_cap = facility_capacity

        # generate list with product and customer location pairs
        key_list_C = []
        for n in self.C:
            for p in self.P:
                key_list_C.append((p, n))
        self.key_list_C = key_list_C

        # generate instance dict that uses ``self.key_list_C`` as keys and
        # ``demand`` as values
        D = {}
        idx = 0
        for key in range(0, len(self.key_list_C)):
            D[self.key_list_C[key]] = demand[idx]
            idx += 1
            if idx &gt;= len(demand):
                idx = 0
        self.D = D

        # calculate total capital invesment cost wrt capacity [euro]
        self.TCI_OCF = (
            six_tenths_rule(
                self.ref_capacity_OCF, self.facility_cap[&#34;OCF&#34;], self.ref_CAPEX_OCF
            )
            * 10**6
        )
        self.TCI_MPF = (
            six_tenths_rule(
                self.ref_capacity_MPF, self.facility_cap[&#34;MPF&#34;], self.ref_CAPEX_MPF
            )
            * 10**6
        )
        self.TCI_CPF = (
            six_tenths_rule(
                self.ref_capacity_CPF, self.facility_cap[&#34;CPF&#34;], self.ref_CAPEX_CPF
            )
            * 10**6
        )
        self.TCI_DPF = (
            six_tenths_rule(
                self.ref_capacity_DPF, self.facility_cap[&#34;DPF&#34;], self.ref_CAPEX_DPF
            )
            * 10**6
        )

        # calculate fixed OPEX wrt capacity [euro/day]
        self.fOPEX_OCF = (
            six_tenths_rule(
                self.ref_capacity_OCF, self.facility_cap[&#34;OCF&#34;], self.ref_fOPEX_OCF
            )
            * 10**6
            / self.working_days
        )
        self.fOPEX_MPF = (
            six_tenths_rule(
                self.ref_capacity_MPF, self.facility_cap[&#34;MPF&#34;], self.ref_fOPEX_MPF
            )
            * 10**6
            / self.working_days
        )
        self.fOPEX_CPF = (
            six_tenths_rule(
                self.ref_capacity_CPF, self.facility_cap[&#34;CPF&#34;], self.ref_fOPEX_CPF
            )
            * 10**6
            / self.working_days
        )
        self.fOPEX_DPF = (
            six_tenths_rule(
                self.ref_capacity_DPF, self.facility_cap[&#34;DPF&#34;], self.ref_fOPEX_DPF
            )
            * 10**6
            / self.working_days
        )

        # calculate annualized capital investment cost per day [euro/day]
        self.ACI_OCF = (
            self.rate
            * self.TCI_OCF
            / (1 - (1 + self.rate) ** (-self.period))
            / self.working_days
        )
        self.ACI_MPF = (
            self.rate
            * self.TCI_MPF
            / (1 - (1 + self.rate) ** (-self.period))
            / self.working_days
        )
        self.ACI_CPF = (
            self.rate
            * self.TCI_CPF
            / (1 - (1 + self.rate) ** (-self.period))
            / self.working_days
        )
        self.ACI_DPF = (
            self.rate
            * self.TCI_DPF
            / (1 - (1 + self.rate) ** (-self.period))
            / self.working_days
        )

        # calculate transportation costs [euro/(km*ton)]
        # ETICS transported in roll-off, determine if volume- or load-limit
        self.TC_ETICS = (
            (self.fuel_price * self.fuel_cons + self.toll_cost)
            + (self.driver_wage / self.driver_hours + self.vehicle_cost_rollof)
            / self.avg_speed
        ) / min(self.rolloff_load, self.rolloff_volume * self.rho_ETICS)
        # compressed ETICS transported in roll-off, determine if v- or l-limit
        self.TC_comp_ETICS = (
            (self.fuel_price * self.fuel_cons + self.toll_cost)
            + (self.driver_wage / self.driver_hours + self.vehicle_cost_rollof)
            / self.avg_speed
        ) / min(self.rolloff_load, self.rolloff_volume * self.rho_compressed_ETICS)
        # pre-concentrate transported in roll-off, determine if v- or l-limit
        self.TC_pre_concentrate = (
            (self.fuel_price * self.fuel_cons + self.toll_cost)
            + (self.driver_wage / self.driver_hours + self.vehicle_cost_rollof)
            / self.avg_speed
        ) / min(self.rolloff_load, self.rolloff_volume * self.rho_pre_concentrate)
        # pyrolysis oil transported in tanker, volume-limited
        self.TC_pyrolysis_oil = (
            (self.fuel_price * self.fuel_cons + self.toll_cost)
            + (self.driver_wage / self.driver_hours + self.vehicle_cost_tanker)
            / self.avg_speed
        ) / (self.tanker_volume * self.rho_pyrolysis_oil)
        # styrene transported in tanker, volume-limited
        self.TC_styrene = (
            (self.fuel_price * self.fuel_cons + self.toll_cost)
            + (self.driver_wage / self.driver_hours + self.vehicle_cost_tanker)
            / self.avg_speed
        ) / (self.tanker_volume * self.rho_styrene)

        # calculate transportation environmental impact [tons CO2-eq/(km*ton)]
        # ETICS, compressed ETICS and pre-concentrate transported in roll-off
        self.TI_ETICS = self.env_rolloff
        self.TI_comp_ETICS = self.env_rolloff
        self.TI_pre_concentrate = self.env_rolloff
        # pyrolysis oil and styrene transported in tanker
        self.TI_pyrolysis_oil = self.env_tanker
        self.TI_styrene = self.env_tanker

    def model_value_chain(self, weight_economic, weight_environmental):
        &#34;&#34;&#34;
        Utilise gurobipy to define a multi-objective optimisation model for the
        user-defined value chain. The model is defined using gurobipy&#39;s blended
        multi-bojective functions. See note below for more information regarding
        how the weights work.

        Parameters
        ----------
        weight_economic (int): weight corresponding to the economic objective
        function

        weight_environmental (int): weight corresponding to the environmental
        objective function

        NOTE: the resulting multi-objective function will be a linear
        combination of the individual objective functions multiplied by their
        corresponding weights, i.e.: weight_economic * obj_economic +
        weight_environmental * obj_environmental
        &#34;&#34;&#34;

        # initialise optimisation problem
        model = gp.Model(&#34;value_chain&#34;)

        # initialise variables whose scope is this function
        b = {}  # binary variable, represents open/close decisions
        x = {}  # continuous variable, represents material flows

        # add solution variables to the optimisation problem
        # product flows from S to OCF
        for p in self.P:
            for i in self.S:
                for j in self.OCF:
                    # Source &gt; Collection Facility
                    x[p, i, j] = model.addVar(
                        vtype=&#34;CONTINUOUS&#34;, lb=0, name=&#34;x(%s,%s,%s)&#34; % (p, i, j)
                    )
        # product flows from OCF to MPF
        for p in self.P:
            for j in self.OCF:
                for k in self.MPF:
                    x[p, j, k] = model.addVar(
                        vtype=&#34;CONTINUOUS&#34;, lb=0, name=&#34;x(%s,%s,%s)&#34; % (p, j, k)
                    )
        # product flows from MPF to CPF
        for p in self.P:
            for k in self.MPF:
                for l in self.CPF:
                    x[p, k, l] = model.addVar(
                        vtype=&#34;CONTINUOUS&#34;, lb=0, name=&#34;x(%s,%s,%s)&#34; % (p, k, l)
                    )
        # product flows from CPF to DPF
        for p in self.P:
            for l in self.CPF:
                for m in self.DPF:
                    x[p, l, m] = model.addVar(
                        vtype=&#34;CONTINUOUS&#34;, lb=0, name=&#34;x(%s,%s,%s)&#34; % (p, l, m)
                    )
        # product flows from DPF to C
        for p in self.P:
            for m in self.DPF:
                for n in self.C:
                    x[p, m, n] = model.addVar(
                        vtype=&#34;CONTINUOUS&#34;, lb=0, name=&#34;x(%s,%s,%s)&#34; % (p, m, n)
                    )
        # OCF installation binary outcomes
        for j in self.OCF:
            b[j] = model.addVar(vtype=&#34;INTEGER&#34;, lb=0, name=&#34;b(%s)&#34; % j)
        # MPF installation binary outcomes
        for k in self.MPF:
            b[k] = model.addVar(vtype=&#34;INTEGER&#34;, lb=0, name=&#34;b(%s)&#34; % k)
        # CPF installation binary outcomes
        for l in self.CPF:
            b[l] = model.addVar(vtype=&#34;INTEGER&#34;, lb=0, name=&#34;b(%s)&#34; % l)
        # DPF installation binary outcomes
        for m in self.DPF:
            b[m] = model.addVar(vtype=&#34;INTEGER&#34;, lb=0, name=&#34;b(%s)&#34; % m)

        # add constraint for flow conservation at sources to the model
        for p in self.P:
            for i in self.S:
                model.addConstr(
                    gp.quicksum(x[p, i, j] for j in self.OCF)
                    == self.source_cap.loc[i, p],
                    name=&#34;Conservation(%s,%s)&#34; % (p, i),
                )

        # add constraints for flow conservation at facilities to the model
        for p in self.P:
            for j in self.OCF:
                # input ETICS, output compressed ETICS
                model.addConstr(
                    self.yield_factor[(p, &#34;OCF&#34;)]
                    * gp.quicksum(x[p, i, j] for i in self.S for p in self.PP)
                    == gp.quicksum(x[p, j, k] for k in self.MPF),
                    name=&#34;Conservation(%s,%s)&#34; % (p, j),
                )
            for k in self.MPF:
                # input compressed ETICS, output pre-concentrate
                model.addConstr(
                    self.yield_factor[(p, &#34;MPF&#34;)]
                    * gp.quicksum(x[p, j, k] for j in self.OCF for p in self.PP)
                    == gp.quicksum(x[p, k, l] for l in self.CPF),
                    name=&#34;Conservation(%s,%s)&#34; % (p, k),
                )
            for l in self.CPF:
                # input pre-concentrate, output pyrolysis oil
                model.addConstr(
                    self.yield_factor[(p, &#34;CPF&#34;)]
                    * gp.quicksum(x[p, k, l] for k in self.MPF for p in self.PP)
                    == gp.quicksum(x[p, l, m] for m in self.DPF),
                    name=&#34;Conservation(%s,%s)&#34; % (p, l),
                )
            for m in self.DPF:
                # input pyrolysis oil, output styrene
                model.addConstr(
                    self.yield_factor[(p, &#34;DPF&#34;)]
                    * gp.quicksum(x[p, l, m] for l in self.CPF for p in self.PP)
                    == gp.quicksum(x[p, m, n] for n in self.C),
                    name=&#34;Conservation(%s,%s)&#34; % (p, m),
                )

        # add capacity constraint for the facilities to the model
        for j in self.OCF:
            model.addConstr(
                gp.quicksum(x[p, i, j] for i in self.S for p in self.P)
                &lt;= b[j] * self.facility_cap[&#34;OCF&#34;],
                name=&#34;Capacity(%s)&#34; % j,
            )
        for k in self.MPF:
            model.addConstr(
                gp.quicksum(x[p, j, k] for j in self.OCF for p in self.P)
                &lt;= b[k] * self.facility_cap[&#34;MPF&#34;],
                name=&#34;Capacity(%s)&#34; % k,
            )
        for l in self.CPF:
            model.addConstr(
                gp.quicksum(x[p, k, l] for k in self.MPF for p in self.P)
                &lt;= b[l] * self.facility_cap[&#34;CPF&#34;],
                name=&#34;Capacity(%s)&#34; % l,
            )
        for m in self.DPF:
            model.addConstr(
                gp.quicksum(x[p, l, m] for l in self.CPF for p in self.P)
                &lt;= b[m] * self.facility_cap[&#34;DPF&#34;],
                name=&#34;Capacity(%s)&#34; % m,
            )

        # add demand satisfaction constraint to the model
        for p in self.P:
            for n in self.C:
                model.addConstr(
                    gp.quicksum(x[p, m, n] for m in self.DPF) &lt;= self.D[(p, n)],
                    name=&#34;Demand(%s,%s)&#34; % (p, n),
                )

        # add driving time constraint for OCFs to the model
        for i in self.S:
            for j in self.OCF:
                model.addConstr(
                    gp.quicksum(x[p, i, j] for p in self.P) * self.D1.loc[i, j]
                    &lt;= (gp.quicksum(x[p, i, j] for p in self.P))
                    * self.avg_speed
                    * self.max_time,
                    name=&#34;Travel Time(%s,%s)&#34; % (j, i),
                )

        # set Gurobi to maximize all objective functions
        model.ModelSense = gp.GRB.MAXIMIZE

        # add economic objective to the model (maximize)
        model.setObjectiveN(
            gp.quicksum(
                self.market_price[p]
                * gp.quicksum(x[p, m, n] for m in self.DPF for n in self.C)
                for p in self.P
            )
            - (
                gp.quicksum(self.ACI_OCF * b[j] for j in self.OCF)
                + gp.quicksum(self.ACI_MPF * b[k] for k in self.MPF)
                + gp.quicksum(self.ACI_CPF * b[l] for l in self.CPF)
                + gp.quicksum(self.ACI_DPF * b[m] for m in self.DPF)
            )
            - (
                gp.quicksum(
                    (
                        self.fOPEX_OCF * b[j]
                        + self.vOPEX_OCF
                        * gp.quicksum(x[p, i, j] for i in self.S for p in self.P)
                    )
                    for j in self.OCF
                )
                + gp.quicksum(
                    (
                        self.fOPEX_MPF * b[k]
                        + self.vOPEX_MPF
                        * gp.quicksum(x[p, j, k] for j in self.OCF for p in self.P)
                    )
                    for k in self.MPF
                )
                + gp.quicksum(
                    (
                        self.fOPEX_CPF * b[l]
                        + self.vOPEX_CPF
                        * gp.quicksum(x[p, k, l] for k in self.MPF for p in self.P)
                    )
                    for l in self.CPF
                )
                + gp.quicksum(
                    (
                        self.fOPEX_DPF * b[m]
                        + self.vOPEX_DPF
                        * gp.quicksum(x[p, l, m] for l in self.CPF for p in self.P)
                    )
                    for m in self.DPF
                )
            )
            - (
                gp.quicksum(
                    2 * self.D1.loc[i, j] * self.TC_ETICS * x[p, i, j]
                    for i in self.S
                    for j in self.OCF
                    for p in self.P
                )
                + gp.quicksum(
                    2 * self.D2.loc[j, k] * self.TC_comp_ETICS * x[p, j, k]
                    for j in self.OCF
                    for k in self.MPF
                    for p in self.P
                )
                + gp.quicksum(
                    2 * self.D3.loc[k, l] * self.TC_pre_concentrate * x[p, k, l]
                    for k in self.MPF
                    for l in self.CPF
                    for p in self.P
                )
                + gp.quicksum(
                    2 * self.D4.loc[l, m] * self.TC_pyrolysis_oil * x[p, l, m]
                    for l in self.CPF
                    for m in self.DPF
                    for p in self.P
                )
                + gp.quicksum(
                    2 * self.D5.loc[m, n] * self.TC_styrene * x[p, m, n]
                    for m in self.DPF
                    for n in self.C
                    for p in self.P
                )
            ),
            0,
            weight=weight_economic,
            name=&#34;obj_economic&#34;,
        )

        # add environmental objective to the model (minimize = -1 * maximize)
        # NOTE: convert to estimated economic cost so blended MOO works
        model.setObjectiveN(
            -1
            * self.env_cost
            * (
                gp.quicksum(
                    (self.CI_OCF + self.OI_OCF)
                    * gp.quicksum(x[p, i, j] for i in self.S for p in self.P)
                    for j in self.OCF
                )
                + gp.quicksum(
                    (self.CI_MPF + self.OI_MPF)
                    * gp.quicksum(x[p, j, k] for j in self.OCF for p in self.P)
                    for k in self.MPF
                )
                + gp.quicksum(
                    (self.CI_CPF + self.OI_CPF)
                    * gp.quicksum(x[p, k, l] for k in self.MPF for p in self.P)
                    for l in self.CPF
                )
                + gp.quicksum(
                    (self.CI_DPF + self.OI_DPF)
                    * gp.quicksum(x[p, l, m] for l in self.CPF for p in self.P)
                    for m in self.DPF
                )
                + gp.quicksum(
                    2 * self.D1.loc[i, j] * self.TI_ETICS * x[p, i, j]
                    for i in self.S
                    for j in self.OCF
                    for p in self.P
                )
                + gp.quicksum(
                    2 * self.D2.loc[j, k] * self.TI_comp_ETICS * x[p, j, k]
                    for j in self.OCF
                    for k in self.MPF
                    for p in self.P
                )
                + gp.quicksum(
                    2 * self.D3.loc[k, l] * self.TI_pre_concentrate * x[p, k, l]
                    for k in self.MPF
                    for l in self.CPF
                    for p in self.P
                )
                + gp.quicksum(
                    2 * self.D4.loc[l, m] * self.TI_pyrolysis_oil * x[p, l, m]
                    for l in self.CPF
                    for m in self.DPF
                    for p in self.P
                )
                + gp.quicksum(
                    2 * self.D5.loc[m, n] * self.TI_styrene * x[p, m, n]
                    for m in self.DPF
                    for n in self.C
                    for p in self.P
                )
            ),
            1,
            weight=weight_environmental,
            name=&#34;obj_environmental&#34;,
        )

        self.x = x
        self.b = b
        self.model = model

    def process_results(self):
        &#34;&#34;&#34;
        Process results for the optimised solution. This function accesses
        solution variables and computes other relevant secondary variables.
        NOTE: this function MUST be called if any further post-processing of the
        results is to be done.
        &#34;&#34;&#34;

        # extract resulting variable values and store them in a dictionary
        vars = {}
        for var in self.model.getVars():
            vars[f&#34;{var.varName}&#34;] = var.x

        # access and store both objective functions (profit &amp; environmental
        # impact expressed as an economic cost)
        self.obj_economic = self.model.getObjective(0).getValue()
        self.obj_environmental = -1 * self.model.getObjective(1).getValue()

        # create ``product_flow`` df for products flowing between facilities
        columns = [&#34;Origin&#34;, &#34;Destination&#34;, &#34;Product&#34;, &#34;Amount&#34;]
        self.product_flow = pd.DataFrame(columns=columns)

        # calculate and store the demand satisfaction
        demand_satisfaction = {}
        for p in self.P:
            for n in self.C:
                demand_satisfaction[(p, n)] = sum(
                    vars[f&#34;x({p},{m},{n})&#34;] for m in self.DPF
                )
        self.demand_satisfaction = demand_satisfaction

        # calculate and store the revenue
        self.Revenue = sum(
            sum(self.market_price[p] * self.demand_satisfaction[(p, n)] for n in self.C)
            for p in self.P
        )

        # process data related to installed OCFs
        name_list_OCF = []
        for j in self.OCF:
            if vars[f&#34;b({j})&#34;] &gt; 0.5:
                name_list_OCF.append(j)
            # add inflowing products to product_flow
            for p in self.P:
                for i in self.S:
                    if vars[f&#34;x({p},{i},{j})&#34;] &gt; 0.001:
                        # append flow data from i to j to DataFrame
                        new_data = {
                            &#34;Origin&#34;: i,
                            &#34;Destination&#34;: j,
                            &#34;Product&#34;: p,
                            &#34;Amount&#34;: vars[f&#34;x({p},{i},{j})&#34;],
                        }
                        self.product_flow = self.product_flow._append(
                            new_data, ignore_index=True
                        )
        self.name_list_OCF = name_list_OCF

        # process data related to installed MPFs
        name_list_MPF = []
        for k in self.MPF:
            if vars[f&#34;b({k})&#34;] &gt; 0.5:
                name_list_MPF.append(k)
            # add inflowing products to product_flow
            for p in self.P:
                for j in self.OCF:
                    if vars[f&#34;x({p},{j},{k})&#34;] &gt; 0.001:
                        # append flow data from j to k to DataFrame
                        new_data = {
                            &#34;Origin&#34;: j,
                            &#34;Destination&#34;: k,
                            &#34;Product&#34;: p,
                            &#34;Amount&#34;: vars[f&#34;x({p},{j},{k})&#34;],
                        }
                        self.product_flow = self.product_flow._append(
                            new_data, ignore_index=True
                        )
        self.name_list_MPF = name_list_MPF

        # process data related to installed CPFs
        name_list_CPF = []
        for l in self.CPF:
            if vars[f&#34;b({l})&#34;] &gt; 0.5:
                name_list_CPF.append(l)
            # add inflowing products to product_flow
            for p in self.P:
                for k in self.MPF:
                    if vars[f&#34;x({p},{k},{l})&#34;] &gt; 0.001:
                        # append flow data from k to l to DataFrame
                        new_data = {
                            &#34;Origin&#34;: k,
                            &#34;Destination&#34;: l,
                            &#34;Product&#34;: p,
                            &#34;Amount&#34;: vars[f&#34;x({p},{k},{l})&#34;],
                        }
                        self.product_flow = self.product_flow._append(
                            new_data, ignore_index=True
                        )
        self.name_list_CPF = name_list_CPF

        # process data related to installed DPFs
        name_list_DPF = []
        for m in self.DPF:
            if vars[f&#34;b({m})&#34;] &gt; 0.5:
                name_list_DPF.append(m)
            # add inflowing &amp; outflowing products to product flow
            for p in self.P:
                # inflowing products
                for l in self.CPF:
                    if vars[f&#34;x({p},{l},{m})&#34;] &gt; 0.001:
                        # append flow data from l to m to DataFrame
                        new_data = {
                            &#34;Origin&#34;: l,
                            &#34;Destination&#34;: m,
                            &#34;Product&#34;: p,
                            &#34;Amount&#34;: vars[f&#34;x({p},{l},{m})&#34;],
                        }
                        self.product_flow = self.product_flow._append(
                            new_data, ignore_index=True
                        )
                # outflowing products
                for n in self.C:
                    if vars[f&#34;x({p},{m},{n})&#34;] &gt; 0.001:
                        # append flow data from m to n to DataFrame
                        new_data = {
                            &#34;Origin&#34;: m,
                            &#34;Destination&#34;: n,
                            &#34;Product&#34;: p,
                            &#34;Amount&#34;: vars[f&#34;x({p},{m},{n})&#34;],
                        }
                        self.product_flow = self.product_flow._append(
                            new_data, ignore_index=True
                        )
        self.name_list_DPF = name_list_DPF

        # save the ``self.product_flow`` DataFrame to a csv file
        self.product_flow.to_csv(&#34;results/product_flow.csv&#34;)

        # compute demand satisfaction of all customers in value chain
        demand_satisfaction = {}
        for p in self.P:
            for n in self.C:
                demand_satisfaction[(p, n)] = sum(
                    vars[f&#34;x({p},{m},{n})&#34;] for m in self.DPF
                )
        self.demand_satisfaction = demand_satisfaction

        # compute individual elements of the economic objective function
        # revenue
        self.Revenue = sum(
            sum(self.market_price[p] * self.demand_satisfaction[(p, n)] for n in self.C)
            for p in self.P
        )
        # transportation costs
        # transportation costs between S and OCF
        self.transportation_cost_1 = sum(
            2
            * self.D1.loc[i, j]
            * self.TC_ETICS
            * sum(vars[f&#34;x({p},{i},{j})&#34;] for p in self.P)
            for i in self.S
            for j in self.OCF
        )
        # transportation costs between OCF and MPF
        self.transportation_cost_2 = sum(
            2
            * self.D2.loc[j, k]
            * self.TC_comp_ETICS
            * sum(vars[f&#34;x({p},{j},{k})&#34;] for p in self.P)
            for j in self.OCF
            for k in self.MPF
        )
        # transportation cost between MPF and CPF
        self.transportation_cost_3 = sum(
            2
            * self.D3.loc[k, l]
            * self.TC_pre_concentrate
            * sum(vars[f&#34;x({p},{k},{l})&#34;] for p in self.P)
            for k in self.MPF
            for l in self.CPF
        )
        # transportation cost between CPF and DPF
        self.transportation_cost_4 = sum(
            2
            * self.D4.loc[l, m]
            * self.TC_pyrolysis_oil
            * sum(vars[f&#34;x({p},{l},{m})&#34;] for p in self.P)
            for l in self.CPF
            for m in self.DPF
        )
        # transportation cost between DPF and C
        self.transportation_cost_5 = sum(
            2
            * self.D5.loc[m, n]
            * self.TC_styrene
            * sum(vars[f&#34;x({p},{m},{n})&#34;] for p in self.P)
            for m in self.DPF
            for n in self.C
        )
        # CAPEX of facilities in the value chain
        self.capex_OCF = sum(self.ACI_OCF * vars[f&#34;b({j})&#34;] for j in self.OCF)
        self.capex_MPF = sum(self.ACI_MPF * vars[f&#34;b({k})&#34;] for k in self.MPF)
        self.capex_CPF = sum(self.ACI_CPF * vars[f&#34;b({l})&#34;] for l in self.CPF)
        self.capex_DPF = sum(self.ACI_DPF * vars[f&#34;b({m})&#34;] for m in self.DPF)
        # OPEX of facilities int he value chain
        self.opex_OCF = sum(
            (
                self.fOPEX_OCF * vars[f&#34;b({j})&#34;]
                + self.vOPEX_OCF
                * sum(vars[f&#34;x({p},{i},{j})&#34;] for i in self.S for p in self.P)
            )
            for j in self.OCF
        )
        self.opex_MPF = sum(
            (
                self.fOPEX_MPF * vars[f&#34;b({k})&#34;]
                + self.vOPEX_MPF
                * sum(vars[f&#34;x({p},{j},{k})&#34;] for j in self.OCF for p in self.P)
            )
            for k in self.MPF
        )
        self.opex_CPF = sum(
            (
                self.fOPEX_CPF * vars[f&#34;b({l})&#34;]
                + self.vOPEX_CPF
                * sum(vars[f&#34;x({p},{k},{l})&#34;] for k in self.MPF for p in self.P)
            )
            for l in self.CPF
        )
        self.opex_DPF = sum(
            (
                self.fOPEX_DPF * vars[f&#34;b({m})&#34;]
                + self.vOPEX_DPF
                * sum(vars[f&#34;x({p},{l},{m})&#34;] for l in self.CPF for p in self.P)
            )
            for m in self.DPF
        )

        # compute individual elements of the environmental objective function
        # transportation impact between S and OCF
        self.transportation_impact_1 = sum(
            2
            * self.D1.loc[i, j]
            * self.TI_ETICS
            * sum(vars[f&#34;x({p},{i},{j})&#34;] for p in self.P)
            for i in self.S
            for j in self.OCF
        )
        # transportation impact between OCF and MPF
        self.transportation_impact_2 = sum(
            2
            * self.D2.loc[j, k]
            * self.TI_comp_ETICS
            * sum(vars[f&#34;x({p},{j},{k})&#34;] for p in self.P)
            for j in self.OCF
            for k in self.MPF
        )
        # transportation impact between MPF and CPF
        self.transportation_impact_3 = sum(
            2
            * self.D3.loc[k, l]
            * self.TI_pre_concentrate
            * sum(vars[f&#34;x({p},{k},{l})&#34;] for p in self.P)
            for k in self.MPF
            for l in self.CPF
        )
        # transportation impact between CPF and DPF
        self.transportation_impact_4 = sum(
            2
            * self.D4.loc[l, m]
            * self.TI_pyrolysis_oil
            * sum(vars[f&#34;x({p},{l},{m})&#34;] for p in self.P)
            for l in self.CPF
            for m in self.DPF
        )
        # transportation impact between DPF and C
        self.transportation_impact_5 = sum(
            2
            * self.D5.loc[m, n]
            * self.TI_styrene
            * sum(vars[f&#34;x({p},{m},{n})&#34;] for p in self.P)
            for m in self.DPF
            for n in self.C
        )
        # construction impact
        self.construction_impact_OCF = sum(
            self.CI_OCF * sum(vars[f&#34;x({p},{i},{j})&#34;] for i in self.S for p in self.P)
            for j in self.OCF
        )
        self.construction_impact_MPF = sum(
            self.CI_MPF * sum(vars[f&#34;x({p},{j},{k})&#34;] for j in self.OCF for p in self.P)
            for k in self.MPF
        )
        self.construction_impact_CPF = sum(
            self.CI_CPF * sum(vars[f&#34;x({p},{k},{l})&#34;] for k in self.MPF for p in self.P)
            for l in self.CPF
        )
        self.construction_impact_DPF = sum(
            self.CI_DPF * sum(vars[f&#34;x({p},{l},{m})&#34;] for l in self.CPF for p in self.P)
            for m in self.DPF
        )
        # operational impact
        self.operational_impact_OCF = sum(
            self.OI_OCF * sum(vars[f&#34;x({p},{i},{j})&#34;] for i in self.S for p in self.P)
            for j in self.OCF
        )
        self.operational_impact_MPF = sum(
            self.OI_MPF * sum(vars[f&#34;x({p},{j},{k})&#34;] for j in self.OCF for p in self.P)
            for k in self.MPF
        )
        self.operational_impact_CPF = sum(
            self.OI_CPF * sum(vars[f&#34;x({p},{k},{l})&#34;] for k in self.MPF for p in self.P)
            for l in self.CPF
        )
        self.operational_impact_DPF = sum(
            self.OI_DPF * sum(vars[f&#34;x({p},{l},{m})&#34;] for l in self.CPF for p in self.P)
            for m in self.DPF
        )

        # compute break-even price of styrene and the LCA&#39;s functional unit
        self.styrene_amount = sum(
            sum(vars[f&#34;x({p},{m},{n})&#34;] for m in self.DPF for p in self.P)
            for n in self.C
        )
        self.break_even_price = (
            abs(self.obj_economic - self.Revenue) / self.styrene_amount
        )
        self.functional_unit = (
            self.obj_environmental / self.env_cost / self.styrene_amount
        )
        print(f&#34;Amount of styrene produced: {self.styrene_amount:.2f} [ton]&#34;)
        print(
            f&#34;Break-even price of styrene: {self.break_even_price:.2f} [euro/ton of styrene]&#34;
        )
        print(
            f&#34;LCA functional unit: {self.functional_unit:.2f} [ton CO2eq/ton of styrene]&#34;
        )

    def plot_infrastructure(self, country=None, img_path=None):
        &#34;&#34;&#34;
        Create plot where the nodes are plotted as a scatter plot with the size
        of the node corresponding to the amount of waste sourced from it. The
        installed facilities (and the presence or lack of customers) is then
        indicated by icons which are used to annotate nodes on the plot.

        Parameters
        ----------
        country (str): optional string containing name of the considered country
        in english, used to obtain the country&#39;s centre and extremes (northmost
        southmost, eastmost, westmost) for setting plot limits

        img_path (str): optional string containing the location of the image
        file which (if specified) will be used as a background for the generated
        plot, REQUIRES ``country`` to be specified as well

        Notes
        -----
        This is a good way for visually inspecting and checking smaller
        networks.
        &#34;&#34;&#34;

        # convert source_cap DataFrame to list containing row sums
        source_cap_row_sums = self.source_cap.sum(axis=1).to_list()
        # extract source coordinates to list
        sources = pd.read_csv(&#34;results/coordinates_sources.csv&#34;)
        x_coords = sources[&#34;xcord&#34;].to_list()
        y_coords = sources[&#34;ycord&#34;].to_list()
        # extract customer coordinates list
        customers = pd.read_csv(&#34;results/coordinates_customers.csv&#34;)
        x_coords_c = customers[&#34;xcord&#34;].to_list()
        y_coords_c = customers[&#34;ycord&#34;].to_list()

        # obtain plot limits using geocoder if ``country`` is specified
        if country != None:
            # obtain corresponding lats and lngs using Nominatim geocoder
            centre = gc.get_country_coords(country)
            bounding_box = gc.get_country_coords(country, output_as=&#34;boundingbox&#34;)
            # calculate x and y distances to the bottom left and top right corners
            bottom_left = cc.coords_to_distances(
                (bounding_box[0], bounding_box[2]), (centre[0], centre[1])
            )
            top_right = cc.coords_to_distances(
                (bounding_box[1], bounding_box[3]), (centre[0], centre[1])
            )
            # extract the required extents for the plot
            x_min = bottom_left[0]
            x_max = top_right[0]
            y_min = bottom_left[1]
            y_max = top_right[1]
        # otherwise, obtain plot limits based on plotted data
        else:
            length_x = max(x_coords) - min(x_coords)
            length_y = max(y_coords) - min(y_coords)

        # convert name_list of installed facilities into an int_list
        int_list_OCF = name_list_to_int_list(self.name_list_OCF)
        int_list_MPF = name_list_to_int_list(self.name_list_MPF)
        int_list_CPF = name_list_to_int_list(self.name_list_CPF)
        int_list_DPF = name_list_to_int_list(self.name_list_DPF)

        # use source row sums to create scatter plot with scaled source size
        fig, ax = plt.subplots(figsize=(8, 8))
        factor = int(300 / max(source_cap_row_sums))
        size = [factor * val for val in source_cap_row_sums]
        ax.scatter(x_coords, y_coords, c=&#34;k&#34;, s=size, zorder=1)
        ax.set_xlabel(&#34;Horizontal distance [km]&#34;)
        ax.set_ylabel(&#34;Vertical distance [km]&#34;)
        # set corresponding limits to the plot
        if country != None:
            ax.set_xlim(x_min * 1.2, x_max * 1.2)
            ax.set_ylim(y_min * 1.2, y_max * 1.2)
        else:
            ax.set_xlim(min(x_coords) - length_x * 0.2, max(x_coords) + length_x * 0.2)
            ax.set_ylim(min(y_coords) - length_y * 0.2, max(y_coords) + length_y * 0.2)
        # set background image if ``img_path`` has been provided
        if img_path != None and country != None:
            background_img = plt.imread(img_path)
            ax.imshow(background_img, zorder=0, extent=[x_min, x_max, y_min, y_max])
        # chosen offset for annotation from the node
        offset = max(20, self.source_cap.values.max() / 60)
        # annotate nodes where OCFs have been installed
        imagebox = osb.OffsetImage(plt.imread(&#34;icons/OCF.png&#34;), zoom=0.03)
        for value in int_list_OCF:
            ab = osb.AnnotationBbox(
                imagebox,
                xy=(x_coords[value], y_coords[value]),
                xybox=(-offset, 0),
                frameon=False,
                boxcoords=&#34;offset points&#34;,
            )
            plt.gca().add_artist(ab)
        # annotate nodes where MPFs have been installed
        imagebox = osb.OffsetImage(plt.imread(&#34;icons/MPF.png&#34;), zoom=0.03)
        for value in int_list_MPF:
            ab = osb.AnnotationBbox(
                imagebox,
                xy=(x_coords[value], y_coords[value]),
                xybox=(-offset * math.sqrt(2) / 2, offset * math.sqrt(2) / 2),
                frameon=False,
                boxcoords=&#34;offset points&#34;,
            )
            plt.gca().add_artist(ab)
        # annnotate nodes where CPFs have been installed
        imagebox = osb.OffsetImage(plt.imread(&#34;icons/CPF.png&#34;), zoom=0.03)
        for value in int_list_CPF:
            ab = osb.AnnotationBbox(
                imagebox,
                xy=(x_coords[value], y_coords[value]),
                xybox=(0, offset),
                frameon=False,
                boxcoords=&#34;offset points&#34;,
            )
            plt.gca().add_artist(ab)
        # annotate nodes where DPFs have been installed
        imagebox = osb.OffsetImage(plt.imread(&#34;icons/DPF.png&#34;), zoom=0.03)
        for value in int_list_DPF:
            ab = osb.AnnotationBbox(
                imagebox,
                xy=(x_coords[value], y_coords[value]),
                xybox=(offset * math.sqrt(2) / 2, offset * math.sqrt(2) / 2),
                frameon=False,
                boxcoords=&#34;offset points&#34;,
            )
            plt.gca().add_artist(ab)
        # annotate nodes where customers are located
        imagebox = osb.OffsetImage(plt.imread(&#34;icons/C.png&#34;), zoom=0.03)
        for idx in range(0, len(x_coords_c)):
            ab = osb.AnnotationBbox(
                imagebox,
                xy=(x_coords_c[idx], y_coords_c[idx]),
                xybox=(offset, 0),
                frameon=False,
                boxcoords=&#34;offset points&#34;,
            )
            plt.gca().add_artist(ab)
        # set plot title
        plt.title(
            f&#34;SY break-even price: {self.break_even_price:_.2f} [euro/ton SY]\nLCA functional unit: {self.functional_unit:_.2f} [ton CO2eq/ton SY]&#34;.replace(
                &#34;_&#34;, &#34;&#39;&#34;
            )
        )
        fig.savefig(
            &#34;results/infrastructure.pdf&#34;, dpi=1200, bbox_inches=&#34;tight&#34;, pad_inches=0.1
        )

    def plot_product_flow(self, country=None, img_path=None, layered=False):
        &#34;&#34;&#34;
        Create a plot where product flows are plotted between nodes represented
        by a scatter plot. The nodes of the scatter plot are scaled according to
        the amount of waste available at them. Product interchange between nodes
        is represented by a line connecting them. The lines and nodes are colour
        and shape coded according to the facilities installed at the node and
        the type of material being transported.

        Parameters
        ----------
        country (str): optional string containing name of the considered country
        in english, used to obtain the country&#39;s centre and extremes (northmost
        southmost, eastmost, westmost) for setting plot limits

        img_path (str): optional string containing the location of the image
        file which (if specified) will be used as a background for the generated
        plot, REQUIRES ``country`` to be specified as well

        layered (bool): optional boolean which is False by default, if set to
        True then the default figure will be generated along with a series of
        figures where the product flow is separeted into layers by plotting each
        product flow type in a separate figure (the layered visualisation is
        useful for analysing complex or very large networks)

        Notes
        -----
        This is a good way for visually inspecting and checking larger networks.
        &#34;&#34;&#34;

        # define colour scheme used throughout using hex notation
        # colours correspond to: yellow, orange, red, purple, indigo
        colours = [&#34;#ffa600&#34;, &#34;#ff6361&#34;, &#34;#bc5090&#34;, &#34;#58508d&#34;, &#34;#003f5c&#34;]

        # convert source_cap DataFrame to list containing row sums
        source_cap_row_sums = self.source_cap.sum(axis=1).to_list()
        # extract source coordinates to list
        sources = pd.read_csv(&#34;results/coordinates_sources.csv&#34;)
        x_coords = sources[&#34;xcord&#34;].to_list()
        y_coords = sources[&#34;ycord&#34;].to_list()
        # convert name_list of installed facilities into an int_list
        int_list_OCF = name_list_to_int_list(self.name_list_OCF)
        int_list_MPF = name_list_to_int_list(self.name_list_MPF)
        int_list_CPF = name_list_to_int_list(self.name_list_CPF)
        int_list_DPF = name_list_to_int_list(self.name_list_DPF)
        # create manual symbols for legend
        point_S = mlines.Line2D(
            [0],
            [0],
            label=&#34;only S&#34;,
            marker=&#34;o&#34;,
            markersize=10,
            markeredgecolor=colours[0],
            markerfacecolor=colours[0],
            linestyle=&#34;&#34;,
        )
        point_OCF = mlines.Line2D(
            [0],
            [0],
            label=&#34;up to OCF&#34;,
            marker=&#34;o&#34;,
            markersize=10,
            markeredgecolor=colours[1],
            markerfacecolor=colours[1],
            linestyle=&#34;&#34;,
        )
        point_MPF = mlines.Line2D(
            [0],
            [0],
            label=&#34;up to MPF&#34;,
            marker=&#34;o&#34;,
            markersize=10,
            markeredgecolor=colours[2],
            markerfacecolor=colours[2],
            linestyle=&#34;&#34;,
        )
        point_CPF = mlines.Line2D(
            [0],
            [0],
            label=&#34;up to CPF&#34;,
            marker=&#34;o&#34;,
            markersize=10,
            markeredgecolor=colours[3],
            markerfacecolor=colours[3],
            linestyle=&#34;&#34;,
        )
        point_DPF = mlines.Line2D(
            [0],
            [0],
            label=&#34;up to DPF&#34;,
            marker=&#34;o&#34;,
            markersize=10,
            markeredgecolor=colours[4],
            markerfacecolor=colours[4],
            linestyle=&#34;&#34;,
        )
        line_ET = mlines.Line2D(
            [0],
            [0],
            label=&#34;ETICS flow&#34;,
            c=colours[0],
        )
        line_CE = mlines.Line2D(
            [0],
            [0],
            label=&#34;compressed ETICS flow&#34;,
            c=colours[1],
        )
        line_PC = mlines.Line2D(
            [0],
            [0],
            label=&#34;pre-concentrate flow&#34;,
            c=colours[2],
        )
        line_PO = mlines.Line2D(
            [0],
            [0],
            label=&#34;pyrolysis oil flow&#34;,
            c=colours[3],
        )
        line_PS = mlines.Line2D(
            [0],
            [0],
            label=&#34;styrene flow&#34;,
            c=colours[4],
        )
        # obtain plot limits using geocoder if ``country`` is specified
        if country != None:
            # obtain corresponding lats and lngs using Nominatim geocoder
            centre = gc.get_country_coords(country)
            bounding_box = gc.get_country_coords(country, output_as=&#34;boundingbox&#34;)
            # calculate x and y distances to the bottom left and top right corners
            bottom_left = cc.coords_to_distances(
                (bounding_box[0], bounding_box[2]), (centre[0], centre[1])
            )
            top_right = cc.coords_to_distances(
                (bounding_box[1], bounding_box[3]), (centre[0], centre[1])
            )
            # extract the required extents for the plot
            x_min = bottom_left[0]
            x_max = top_right[0]
            y_min = bottom_left[1]
            y_max = top_right[1]
        # otherwise, obtain plot limits based on plotted data
        else:
            length_x = max(x_coords) - min(x_coords)
            length_y = max(y_coords) - min(y_coords)

        # create the default unlayered figure
        fig, ax = plt.subplots(figsize=(8, 8))
        ax.set_xlabel(&#34;Horizontal distance [km]&#34;)
        ax.set_ylabel(&#34;Vertical distance [km]&#34;)
        # set corresponding limits to the plot
        if country != None:
            ax.set_xlim(x_min * 1.2, x_max * 1.2)
            ax.set_ylim(y_min * 1.2, y_max * 1.5)
        else:
            ax.set_xlim(min(x_coords) - length_x * 0.2, max(x_coords) + length_x * 0.2)
            ax.set_ylim(min(y_coords) - length_y * 0.2, max(y_coords) + length_y * 0.5)
        # set background image if ``img_path`` has been provided
        if img_path != None and country != None:
            background_img = plt.imread(img_path)
            ax.imshow(background_img, zorder=0, extent=[x_min, x_max, y_min, y_max])
        # loop over the source coordinates (that is, number of nodes)
        factor = int(300 / max(source_cap_row_sums))
        for idx in range(0, len(x_coords)):
            # plot node with select node colour
            if idx in int_list_DPF:
                colour = colours[4]
            elif idx in int_list_CPF:
                colour = colours[3]
            elif idx in int_list_MPF:
                colour = colours[2]
            elif idx in int_list_OCF:
                colour = colours[1]
            else:
                colour = colours[0]
            # plot the node
            plt.scatter(
                x_coords[idx],
                y_coords[idx],
                c=colour,
                s=source_cap_row_sums[idx] * factor,
                zorder=2.5,
            )
        # draw lines representing exchanged products
        product_flows = pd.read_csv(&#34;results/product_flow.csv&#34;)
        for _, row in product_flows.iterrows():
            origin_int = name_to_int(row[&#34;Origin&#34;])
            destination_int = name_to_int(row[&#34;Destination&#34;])
            # draw line only if origin and destination have different node num.
            if origin_int != destination_int:
                # plot line with selected product flow colour
                if row[&#34;Product&#34;] == &#34;ETICS&#34;:
                    colour = colours[0]
                elif row[&#34;Product&#34;] == &#34;compressed_ETICS&#34;:
                    colour = colours[1]
                elif row[&#34;Product&#34;] == &#34;pre_concentrate&#34;:
                    colour = colours[2]
                elif row[&#34;Product&#34;] == &#34;pyrolysis_oil&#34;:
                    colour = colours[3]
                else:
                    colour = colours[4]
                # draw the corresponding product flow line
                x = (x_coords[origin_int], x_coords[destination_int])
                y = (y_coords[origin_int], y_coords[destination_int])
                plt.plot(x, y, lw=2, c=colour)
                # annotate the line with an arrow showing flow direction
                x_diff = x_coords[destination_int] - x_coords[origin_int]
                y_diff = y_coords[destination_int] - y_coords[origin_int]
                plt.annotate(
                    &#34;&#34;,
                    xy=(
                        x_coords[origin_int] + 0.8 * x_diff,
                        y_coords[origin_int] + 0.8 * y_diff,
                    ),
                    xytext=(
                        x_coords[origin_int] + 0.6 * x_diff,
                        y_coords[origin_int] + 0.6 * y_diff,
                    ),
                    arrowprops=dict(
                        arrowstyle=&#34;-&gt;&#34;, lw=2, color=colour, mutation_scale=25
                    ),
                    zorder=1,
                )
        plt.legend(
            handles=[
                point_S,
                point_OCF,
                point_MPF,
                point_CPF,
                point_DPF,
                line_ET,
                line_CE,
                line_PC,
                line_PO,
                line_PS,
            ],
            loc=&#34;upper right&#34;,
            ncol=2,
            frameon=False,
        )
        plt.title(
            f&#34;SY break-even price: {self.break_even_price:_.2f} [euro/ton SY]\nLCA functional unit: {self.functional_unit:_.2f} [ton CO2eq/ton SY]&#34;.replace(
                &#34;_&#34;, &#34;&#39;&#34;
            )
        )
        fig.savefig(
            &#34;results/product_flow.pdf&#34;, dpi=1200, bbox_inches=&#34;tight&#34;, pad_inches=0.1
        )

        # create layered figure if specified
        if layered:
            # loop over the number of layers required &amp; clear existing figure
            plt.clf()
            for layer in range(0, len(colours)):
                fig, ax = plt.subplots(figsize=(8, 8))
                ax.set_xlabel(&#34;Horizontal distance [km]&#34;)
                ax.set_ylabel(&#34;Vertical distance [km]&#34;)
                # set corresponding limits to the plot
                if country != None:
                    ax.set_xlim(x_min * 1.2, x_max * 1.2)
                    ax.set_ylim(y_min * 1.2, y_max * 1.5)
                else:
                    ax.set_xlim(
                        min(x_coords) - length_x * 0.2, max(x_coords) + length_x * 0.2
                    )
                    ax.set_ylim(
                        min(y_coords) - length_y * 0.2, max(y_coords) + length_y * 0.5
                    )
                # set background image if ``img_path`` has been provided
                if img_path != None and country != None:
                    background_img = plt.imread(img_path)
                    ax.imshow(
                        background_img, zorder=0, extent=[x_min, x_max, y_min, y_max]
                    )
                # loop over the source coordinates (that is, number of nodes)
                # create a scatter plont of all nodes
                factor = int(300 / max(source_cap_row_sums))
                for idx in range(0, len(x_coords)):
                    # plot node with select node colour
                    if idx in int_list_DPF:
                        colour = colours[4]
                    elif idx in int_list_CPF:
                        colour = colours[3]
                    elif idx in int_list_MPF:
                        colour = colours[2]
                    elif idx in int_list_OCF:
                        colour = colours[1]
                    else:
                        colour = colours[0]
                    # plot the node
                    plt.scatter(
                        x_coords[idx],
                        y_coords[idx],
                        c=colour,
                        s=source_cap_row_sums[idx] * factor,
                        zorder=2.5,
                    )
                # draw lines representing product flow ONLY on current layer
                product_flows = pd.read_csv(&#34;results/product_flow.csv&#34;)
                title = f&#34;Layer: {self.P[layer]} flow&#34;.replace(&#34;_&#34;, &#34; &#34;)
                for _, row in product_flows.iterrows():
                    origin_int = name_to_int(row[&#34;Origin&#34;])
                    destination_int = name_to_int(row[&#34;Destination&#34;])
                    # draw line only if origin &amp; destination have diff node num.
                    if origin_int != destination_int:
                        # plot lines only if they should appear on current layer
                        if self.P.index(row[&#34;Product&#34;]) == layer:
                            colour = colours[layer]
                            # draw the corresponding product flow line
                            x = (x_coords[origin_int], x_coords[destination_int])
                            y = (y_coords[origin_int], y_coords[destination_int])
                            plt.plot(x, y, lw=2, c=colour)
                            # annotate w arrow showing flow direction
                            x_diff = x_coords[destination_int] - x_coords[origin_int]
                            y_diff = y_coords[destination_int] - y_coords[origin_int]
                            plt.annotate(
                                &#34;&#34;,
                                xy=(
                                    x_coords[origin_int] + 0.8 * x_diff,
                                    y_coords[origin_int] + 0.8 * y_diff,
                                ),
                                xytext=(
                                    x_coords[origin_int] + 0.6 * x_diff,
                                    y_coords[origin_int] + 0.6 * y_diff,
                                ),
                                arrowprops=dict(
                                    arrowstyle=&#34;-&gt;&#34;,
                                    lw=2,
                                    color=colour,
                                    mutation_scale=25,
                                ),
                                zorder=1,
                            )
                        else:
                            continue
                # finish annotating figure and save it
                plt.legend(
                    handles=[
                        point_S,
                        point_OCF,
                        point_MPF,
                        point_CPF,
                        point_DPF,
                        line_ET,
                        line_CE,
                        line_PC,
                        line_PO,
                        line_PS,
                    ],
                    loc=&#34;upper right&#34;,
                    ncol=2,
                    frameon=False,
                )
                plt.title(title)
                file_name = f&#34;results/product_flow_layer{layer}.pdf&#34;
                fig.savefig(file_name, dpi=1200, bbox_inches=&#34;tight&#34;, pad_inches=0.1)

    def plot_objective_function_breakdown(self):
        &#34;&#34;&#34;
        Function for plotting a bar graph where the individual components of
        both the economic and environmental objective functions are broken down.
        The plot generates an individual subplot for each of the objective
        functions.

        Notes
        -----
        This is an excellent method for comparing where the costs and
        environmental impacts occur in different networks.
        &#34;&#34;&#34;

        # define colour scheme used throughout using hex notation
        # colours correspond to: yellow, orange, red, purple, indigo
        colours = [&#34;#ffa600&#34;, &#34;#ff6361&#34;, &#34;#bc5090&#34;, &#34;#58508d&#34;, &#34;#003f5c&#34;]

        # define number of categories
        N = 3

        # clear the figure
        plt.clf()
        # configure figure fonts
        plt.rcParams[&#34;font.size&#34;] = 16

        # define economic subcategories and their values
        ETICS = (self.transportation_cost_1, 0, 0)
        compressed_ETICS = (
            self.transportation_cost_2,
            self.capex_OCF,
            self.opex_OCF,
        )
        pre_concentrate = (
            self.transportation_cost_3,
            self.capex_MPF,
            self.opex_MPF,
        )
        pyrolysis_oil = (
            self.transportation_cost_4,
            self.capex_CPF,
            self.opex_CPF,
        )
        styrene = (
            self.transportation_cost_5,
            self.capex_DPF,
            self.opex_DPF,
        )

        # define the bottoms using numpy to add the tuples
        bottom3 = np.add(np.array(ETICS), np.array(compressed_ETICS))
        bottom4 = np.add(np.array(bottom3), np.array(pre_concentrate))
        bottom5 = np.add(np.array(bottom4), np.array(pyrolysis_oil))

        # plot the bar graphs for the economic values and save the figure
        ind = np.arange(N)
        width = 0.65
        fig, ax = plt.subplots(figsize=(8, 8))
        b1 = ax.bar(ind, ETICS, width, color=colours[0])
        b2 = ax.bar(ind, compressed_ETICS, width, bottom=ETICS, color=colours[1])
        b3 = ax.bar(
            ind,
            pre_concentrate,
            width,
            bottom=bottom3,
            color=colours[2],
        )
        b4 = ax.bar(
            ind,
            pyrolysis_oil,
            width,
            bottom=bottom4,
            color=colours[3],
        )
        b5 = ax.bar(
            ind,
            styrene,
            width,
            bottom=bottom5,
            color=colours[4],
        )
        ax.set_ylabel(&#34;Economic cost [euro/day]&#34;)
        ax.set_xticks(ind, (&#34;TC&#34;, &#34;CAPEX&#34;, &#34;OPEX&#34;))
        ax.legend(
            (b1[0], b2[0], b3[0], b4[0], b5[0]),
            (
                &#34;ET&#34;,
                &#34;CE or OCF&#34;,
                &#34;PC or MPF&#34;,
                &#34;PO or CPF&#34;,
                &#34;SY or DPF&#34;,
            ),
            loc=&#34;upper left&#34;,
        )
        ax.set_title(
            f&#34;Total economic cost: {abs(self.obj_economic - self.Revenue):_.2f} euro/day&#34;.replace(
                &#34;_&#34;, &#34;&#39;&#34;
            )
        )
        fig.savefig(
            &#34;results/economic_objective_breakdown.pdf&#34;,
            dpi=1200,
            bbox_inches=&#34;tight&#34;,
            pad_inches=0.1,
        )

        # clear the figure
        plt.clf()

        # define environmental subcategories and their values
        ETICS = (float(self.transportation_impact_1), float(0), float(0))
        compressed_ETICS = (
            self.transportation_impact_2,
            self.construction_impact_OCF,
            self.operational_impact_OCF,
        )
        pre_concentrate = (
            self.transportation_impact_3,
            self.construction_impact_MPF,
            self.operational_impact_MPF,
        )
        pyrolysis_oil = (
            self.transportation_impact_4,
            self.construction_impact_CPF,
            self.operational_impact_CPF,
        )
        styrene = (
            self.transportation_impact_5,
            self.construction_impact_DPF,
            self.operational_impact_DPF,
        )

        # define the bottoms using numpy to add the tuples
        bottom3 = np.add(np.array(ETICS), np.array(compressed_ETICS))
        bottom4 = np.add(np.array(bottom3), np.array(pre_concentrate))
        bottom5 = np.add(np.array(bottom4), np.array(pyrolysis_oil))

        # plot the bar graphs for the environmental values and save the figure
        ind = np.arange(N)
        width = 0.65
        fig, ax = plt.subplots(figsize=(8, 8))
        b1 = ax.bar(ind, ETICS, width, color=colours[0])
        b2 = ax.bar(ind, compressed_ETICS, width, bottom=ETICS, color=colours[1])
        b3 = ax.bar(
            ind,
            pre_concentrate,
            width,
            bottom=bottom3,
            color=colours[2],
        )
        b4 = ax.bar(
            ind,
            pyrolysis_oil,
            width,
            bottom=bottom4,
            color=colours[3],
        )
        b5 = ax.bar(
            ind,
            styrene,
            width,
            bottom=bottom5,
            color=colours[4],
        )
        ax.set_ylabel(&#34;Environmental impact [tons CO2-eq/day]&#34;)
        ax.set_xticks(ind, (&#34;TI&#34;, &#34;CI&#34;, &#34;OI&#34;))
        ax.legend(
            (b1[0], b2[0], b3[0], b4[0], b5[0]),
            (
                &#34;ET&#34;,
                &#34;CE or OCF&#34;,
                &#34;PC or MPF&#34;,
                &#34;PO or CPF&#34;,
                &#34;SY or DPF&#34;,
            ),
            loc=&#34;upper left&#34;,
        )
        ax.set_title(
            f&#34;Total environmental impact: {self.obj_environmental/self.env_cost:_.2f} tons CO2-eq/day&#34;.replace(
                &#34;_&#34;, &#34;&#39;&#34;
            )
        )
        fig.savefig(
            &#34;results/environmental_objective_breakdown.pdf&#34;,
            dpi=1200,
            bbox_inches=&#34;tight&#34;,
            pad_inches=0.1,
        )

    def tabulate_product_flows(self):
        &#34;&#34;&#34;
        Generate a table with the facility types as columns and the node numbers
        as rows. The cells are populated with the amount of product flowing
        through a specific type of facility in a specific node [tons/day], along
        with the number of facilities installed and their capacity in
        parenthesis. Two tables are generated from the results: one through
        creating a tex file and callind pdflatex, and one using Seaborn which
        displays only teh values (not the number of installed facilities).
        &#34;&#34;&#34;

        # extract resulting variable values and store them in a dictionary
        vars = {}
        for var in self.model.getVars():
            vars[f&#34;{var.varName}&#34;] = var.x

        # read the product_flow csv using pandas
        product_flows = pd.read_csv(&#34;results/product_flow.csv&#34;)

        # generate a pandas dataframe for the tabulation
        columns = [&#34;OCF [ton/day]&#34;, &#34;MPF [ton/day]&#34;, &#34;CPF [ton/day]&#34;, &#34;DPF [ton/day]&#34;]
        tabulated_product_flow = pd.DataFrame(columns=columns)
        tabulated_product_flow.rename_axis(&#34;node&#34;, axis=1)
        # generate another dataframe which will store only the values
        tabulated_product_flow_val = pd.DataFrame(columns=columns)
        tabulated_product_flow_val.rename_axis(&#34;node&#34;, axis=1)

        # loop over the nodes in the network
        sources = pd.read_csv(&#34;results/coordinates_sources.csv&#34;)
        x_coords = sources[&#34;xcord&#34;].to_list()
        for node in range(0, len(x_coords)):
            # filter the df using OCF &amp; current node, then extract info
            name = f&#34;OCF_{node}&#34;
            OCF_amount = 0
            filtered = product_flows[product_flows[&#34;Destination&#34;] == name]
            for _, row in filtered.iterrows():
                OCF_amount += row[&#34;Amount&#34;]
            OCF_installed = abs(vars[f&#34;b({name})&#34;])
            OCF_entry = f&#34;{OCF_amount:.1f} ({OCF_installed:.0f} * {self.facility_cap[&#39;OCF&#39;]:.1f})&#34;
            OCF_entry_val = OCF_amount

            # filter the df using MPF &amp; current node, then extract info
            name = f&#34;MPF_{node}&#34;
            MPF_amount = 0
            filtered = product_flows[product_flows[&#34;Destination&#34;] == name]
            for _, row in filtered.iterrows():
                MPF_amount += row[&#34;Amount&#34;]
            MPF_installed = abs(vars[f&#34;b({name})&#34;])
            MPF_entry = f&#34;{MPF_amount:.1f} ({MPF_installed:.0f} * {self.facility_cap[&#39;MPF&#39;]:.1f})&#34;
            MPF_entry_val = MPF_amount

            # filter the df using CPF &amp; current node, then extract info
            name = f&#34;CPF_{node}&#34;
            CPF_amount = 0
            filtered = product_flows[product_flows[&#34;Destination&#34;] == name]
            for _, row in filtered.iterrows():
                CPF_amount += row[&#34;Amount&#34;]
            CPF_installed = abs(vars[f&#34;b({name})&#34;])
            CPF_entry = f&#34;{CPF_amount:.1f} ({CPF_installed:.0f} * {self.facility_cap[&#39;CPF&#39;]:.1f})&#34;
            CPF_entry_val = CPF_amount

            # filter the df using DPF &amp; current node, then extract info
            name = f&#34;DPF_{node}&#34;
            DPF_amount = 0
            filtered = product_flows[product_flows[&#34;Destination&#34;] == name]
            for _, row in filtered.iterrows():
                DPF_amount += row[&#34;Amount&#34;]
            DPF_installed = abs(vars[f&#34;b({name})&#34;])
            DPF_entry = f&#34;{DPF_amount:.1f} ({DPF_installed:.0f} * {self.facility_cap[&#39;DPF&#39;]:.1f})&#34;
            DPF_entry_val = DPF_amount

            # construct new data for this node and append it to the dataframe
            new_data = {
                &#34;OCF [ton/day]&#34;: OCF_entry,
                &#34;MPF [ton/day]&#34;: MPF_entry,
                &#34;CPF [ton/day]&#34;: CPF_entry,
                &#34;DPF [ton/day]&#34;: DPF_entry,
            }
            tabulated_product_flow = tabulated_product_flow._append(
                new_data, ignore_index=True
            )
            # do the same for the dataframe containing only the values
            new_data_val = {
                &#34;OCF [ton/day]&#34;: OCF_entry_val,
                &#34;MPF [ton/day]&#34;: MPF_entry_val,
                &#34;CPF [ton/day]&#34;: CPF_entry_val,
                &#34;DPF [ton/day]&#34;: DPF_entry_val,
            }
            tabulated_product_flow_val = tabulated_product_flow_val._append(
                new_data_val, ignore_index=True
            )

        # name index columns of both dataframes
        tabulated_product_flow.index.name = &#34;node&#34;
        tabulated_product_flow_val.index.name = &#34;node&#34;

        # save the dataframe as a table in pdf format using latex
        filename = &#34;results/tabulated_product_flow.tex&#34;
        directory = &#34;results/&#34;
        template = r&#34;&#34;&#34;\documentclass[preview]{{standalone}}
        \usepackage{{booktabs}}
        \begin{{document}}
        {}
        \end{{document}}
        &#34;&#34;&#34;
        with open(filename, &#34;w&#34;) as f:
            f.write(template.format(tabulated_product_flow.to_latex()))
        # subprocess.call([&#34;pdflatex&#34;, filename])
        subprocess.run(
            [&#34;pdflatex&#34;, &#34;-output-directory=&#34; + directory, filename],
            stdout=subprocess.PIPE,
        )
        # generate Seaborn heatmap
        plt.clf()
        sns.heatmap(
            tabulated_product_flow_val,
            annot=True,
            cmap=&#34;Reds&#34;,
            yticklabels=tabulated_product_flow_val.index[::-1],
        )
        plt.savefig(
            &#34;results/tabulated_product_flow_heatmap.pdf&#34;,
            dpi=1200,
            bbox_inches=&#34;tight&#34;,
            pad_inches=0.1,
        )</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.CI_CPF"><code class="name">var <span class="ident">CI_CPF</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.CI_DPF"><code class="name">var <span class="ident">CI_DPF</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.CI_MPF"><code class="name">var <span class="ident">CI_MPF</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.CI_OCF"><code class="name">var <span class="ident">CI_OCF</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.OI_CPF"><code class="name">var <span class="ident">OI_CPF</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.OI_DPF"><code class="name">var <span class="ident">OI_DPF</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.OI_MPF"><code class="name">var <span class="ident">OI_MPF</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.OI_OCF"><code class="name">var <span class="ident">OI_OCF</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.avg_speed"><code class="name">var <span class="ident">avg_speed</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.circuit_factor"><code class="name">var <span class="ident">circuit_factor</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.driver_hours"><code class="name">var <span class="ident">driver_hours</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.driver_wage"><code class="name">var <span class="ident">driver_wage</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.env_cost"><code class="name">var <span class="ident">env_cost</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.env_rolloff"><code class="name">var <span class="ident">env_rolloff</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.env_tanker"><code class="name">var <span class="ident">env_tanker</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.fuel_cons"><code class="name">var <span class="ident">fuel_cons</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.fuel_price"><code class="name">var <span class="ident">fuel_price</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.max_time"><code class="name">var <span class="ident">max_time</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.period"><code class="name">var <span class="ident">period</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.rate"><code class="name">var <span class="ident">rate</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.ref_CAPEX_CPF"><code class="name">var <span class="ident">ref_CAPEX_CPF</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.ref_CAPEX_DPF"><code class="name">var <span class="ident">ref_CAPEX_DPF</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.ref_CAPEX_MPF"><code class="name">var <span class="ident">ref_CAPEX_MPF</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.ref_CAPEX_OCF"><code class="name">var <span class="ident">ref_CAPEX_OCF</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.ref_capacity_CPF"><code class="name">var <span class="ident">ref_capacity_CPF</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.ref_capacity_DPF"><code class="name">var <span class="ident">ref_capacity_DPF</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.ref_capacity_MPF"><code class="name">var <span class="ident">ref_capacity_MPF</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.ref_capacity_OCF"><code class="name">var <span class="ident">ref_capacity_OCF</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.ref_fOPEX_CPF"><code class="name">var <span class="ident">ref_fOPEX_CPF</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.ref_fOPEX_DPF"><code class="name">var <span class="ident">ref_fOPEX_DPF</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.ref_fOPEX_MPF"><code class="name">var <span class="ident">ref_fOPEX_MPF</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.ref_fOPEX_OCF"><code class="name">var <span class="ident">ref_fOPEX_OCF</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.rho_ETICS"><code class="name">var <span class="ident">rho_ETICS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.rho_compressed_ETICS"><code class="name">var <span class="ident">rho_compressed_ETICS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.rho_pre_concentrate"><code class="name">var <span class="ident">rho_pre_concentrate</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.rho_pyrolysis_oil"><code class="name">var <span class="ident">rho_pyrolysis_oil</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.rho_styrene"><code class="name">var <span class="ident">rho_styrene</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.rolloff_load"><code class="name">var <span class="ident">rolloff_load</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.rolloff_volume"><code class="name">var <span class="ident">rolloff_volume</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.tanker_volume"><code class="name">var <span class="ident">tanker_volume</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.toll_cost"><code class="name">var <span class="ident">toll_cost</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.vOPEX_CPF"><code class="name">var <span class="ident">vOPEX_CPF</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.vOPEX_DPF"><code class="name">var <span class="ident">vOPEX_DPF</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.vOPEX_MPF"><code class="name">var <span class="ident">vOPEX_MPF</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.vOPEX_OCF"><code class="name">var <span class="ident">vOPEX_OCF</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.vehicle_cost_rollof"><code class="name">var <span class="ident">vehicle_cost_rollof</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.vehicle_cost_tanker"><code class="name">var <span class="ident">vehicle_cost_tanker</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.working_days"><code class="name">var <span class="ident">working_days</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.define_value_chain"><code class="name flex">
<span>def <span class="ident">define_value_chain</span></span>(<span>self, products, source_capacity, facility_capacity, demand, yield_factor, market_price)</span>
</code></dt>
<dd>
<div class="desc"><p>Define the value chain by specifying product- and capacity-specific
parameters.</p>
<h2 id="parameters">Parameters</h2>
<p>products (list): contains names of products in value chain</p>
<p>source_capacity (DataFrame): contains source capacities [tons]</p>
<p>facility_capacity (dict): contains facilities as keys and capacities as
values [tons]</p>
<p>demand (list): contains demand of all products [tons]</p>
<p>yield_factor (dict): contains product and facility type as keys and
corresponding yield factors as values</p>
<p>market_price (dict): contains products as keys and market price as
values [euro/ton]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def define_value_chain(
    self,
    products,
    source_capacity,
    facility_capacity,
    demand,
    yield_factor,
    market_price,
):
    &#34;&#34;&#34;
    Define the value chain by specifying product- and capacity-specific
    parameters.

    Parameters
    ----------
    products (list): contains names of products in value chain

    source_capacity (DataFrame): contains source capacities [tons]

    facility_capacity (dict): contains facilities as keys and capacities as
    values [tons]

    demand (list): contains demand of all products [tons]

    yield_factor (dict): contains product and facility type as keys and
    corresponding yield factors as values

    market_price (dict): contains products as keys and market price as
    values [euro/ton]
    &#34;&#34;&#34;

    # initialise instance variables from provided parameters
    self.P = products
    self.PP = products  # P subset used when products transformed @ facility
    self.source_cap = source_capacity
    self.yield_factor = yield_factor
    self.market_price = market_price
    self.facility_cap = facility_capacity

    # generate list with product and customer location pairs
    key_list_C = []
    for n in self.C:
        for p in self.P:
            key_list_C.append((p, n))
    self.key_list_C = key_list_C

    # generate instance dict that uses ``self.key_list_C`` as keys and
    # ``demand`` as values
    D = {}
    idx = 0
    for key in range(0, len(self.key_list_C)):
        D[self.key_list_C[key]] = demand[idx]
        idx += 1
        if idx &gt;= len(demand):
            idx = 0
    self.D = D

    # calculate total capital invesment cost wrt capacity [euro]
    self.TCI_OCF = (
        six_tenths_rule(
            self.ref_capacity_OCF, self.facility_cap[&#34;OCF&#34;], self.ref_CAPEX_OCF
        )
        * 10**6
    )
    self.TCI_MPF = (
        six_tenths_rule(
            self.ref_capacity_MPF, self.facility_cap[&#34;MPF&#34;], self.ref_CAPEX_MPF
        )
        * 10**6
    )
    self.TCI_CPF = (
        six_tenths_rule(
            self.ref_capacity_CPF, self.facility_cap[&#34;CPF&#34;], self.ref_CAPEX_CPF
        )
        * 10**6
    )
    self.TCI_DPF = (
        six_tenths_rule(
            self.ref_capacity_DPF, self.facility_cap[&#34;DPF&#34;], self.ref_CAPEX_DPF
        )
        * 10**6
    )

    # calculate fixed OPEX wrt capacity [euro/day]
    self.fOPEX_OCF = (
        six_tenths_rule(
            self.ref_capacity_OCF, self.facility_cap[&#34;OCF&#34;], self.ref_fOPEX_OCF
        )
        * 10**6
        / self.working_days
    )
    self.fOPEX_MPF = (
        six_tenths_rule(
            self.ref_capacity_MPF, self.facility_cap[&#34;MPF&#34;], self.ref_fOPEX_MPF
        )
        * 10**6
        / self.working_days
    )
    self.fOPEX_CPF = (
        six_tenths_rule(
            self.ref_capacity_CPF, self.facility_cap[&#34;CPF&#34;], self.ref_fOPEX_CPF
        )
        * 10**6
        / self.working_days
    )
    self.fOPEX_DPF = (
        six_tenths_rule(
            self.ref_capacity_DPF, self.facility_cap[&#34;DPF&#34;], self.ref_fOPEX_DPF
        )
        * 10**6
        / self.working_days
    )

    # calculate annualized capital investment cost per day [euro/day]
    self.ACI_OCF = (
        self.rate
        * self.TCI_OCF
        / (1 - (1 + self.rate) ** (-self.period))
        / self.working_days
    )
    self.ACI_MPF = (
        self.rate
        * self.TCI_MPF
        / (1 - (1 + self.rate) ** (-self.period))
        / self.working_days
    )
    self.ACI_CPF = (
        self.rate
        * self.TCI_CPF
        / (1 - (1 + self.rate) ** (-self.period))
        / self.working_days
    )
    self.ACI_DPF = (
        self.rate
        * self.TCI_DPF
        / (1 - (1 + self.rate) ** (-self.period))
        / self.working_days
    )

    # calculate transportation costs [euro/(km*ton)]
    # ETICS transported in roll-off, determine if volume- or load-limit
    self.TC_ETICS = (
        (self.fuel_price * self.fuel_cons + self.toll_cost)
        + (self.driver_wage / self.driver_hours + self.vehicle_cost_rollof)
        / self.avg_speed
    ) / min(self.rolloff_load, self.rolloff_volume * self.rho_ETICS)
    # compressed ETICS transported in roll-off, determine if v- or l-limit
    self.TC_comp_ETICS = (
        (self.fuel_price * self.fuel_cons + self.toll_cost)
        + (self.driver_wage / self.driver_hours + self.vehicle_cost_rollof)
        / self.avg_speed
    ) / min(self.rolloff_load, self.rolloff_volume * self.rho_compressed_ETICS)
    # pre-concentrate transported in roll-off, determine if v- or l-limit
    self.TC_pre_concentrate = (
        (self.fuel_price * self.fuel_cons + self.toll_cost)
        + (self.driver_wage / self.driver_hours + self.vehicle_cost_rollof)
        / self.avg_speed
    ) / min(self.rolloff_load, self.rolloff_volume * self.rho_pre_concentrate)
    # pyrolysis oil transported in tanker, volume-limited
    self.TC_pyrolysis_oil = (
        (self.fuel_price * self.fuel_cons + self.toll_cost)
        + (self.driver_wage / self.driver_hours + self.vehicle_cost_tanker)
        / self.avg_speed
    ) / (self.tanker_volume * self.rho_pyrolysis_oil)
    # styrene transported in tanker, volume-limited
    self.TC_styrene = (
        (self.fuel_price * self.fuel_cons + self.toll_cost)
        + (self.driver_wage / self.driver_hours + self.vehicle_cost_tanker)
        / self.avg_speed
    ) / (self.tanker_volume * self.rho_styrene)

    # calculate transportation environmental impact [tons CO2-eq/(km*ton)]
    # ETICS, compressed ETICS and pre-concentrate transported in roll-off
    self.TI_ETICS = self.env_rolloff
    self.TI_comp_ETICS = self.env_rolloff
    self.TI_pre_concentrate = self.env_rolloff
    # pyrolysis oil and styrene transported in tanker
    self.TI_pyrolysis_oil = self.env_tanker
    self.TI_styrene = self.env_tanker</code></pre>
</details>
</dd>
<dt id="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.model_value_chain"><code class="name flex">
<span>def <span class="ident">model_value_chain</span></span>(<span>self, weight_economic, weight_environmental)</span>
</code></dt>
<dd>
<div class="desc"><p>Utilise gurobipy to define a multi-objective optimisation model for the
user-defined value chain. The model is defined using gurobipy's blended
multi-bojective functions. See note below for more information regarding
how the weights work.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt>weight_economic (int): weight corresponding to the economic objective</dt>
<dt><strong><code>function</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<p>weight_environmental (int): weight corresponding to the environmental
objective function</p>
<dl>
<dt><strong><code>NOTE</code></strong> :&ensp;<code>the resulting multi-objective function will be a linear</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>combination of the individual objective functions multiplied by their
corresponding weights, i.e.: weight_economic * obj_economic +
weight_environmental * obj_environmental</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def model_value_chain(self, weight_economic, weight_environmental):
    &#34;&#34;&#34;
    Utilise gurobipy to define a multi-objective optimisation model for the
    user-defined value chain. The model is defined using gurobipy&#39;s blended
    multi-bojective functions. See note below for more information regarding
    how the weights work.

    Parameters
    ----------
    weight_economic (int): weight corresponding to the economic objective
    function

    weight_environmental (int): weight corresponding to the environmental
    objective function

    NOTE: the resulting multi-objective function will be a linear
    combination of the individual objective functions multiplied by their
    corresponding weights, i.e.: weight_economic * obj_economic +
    weight_environmental * obj_environmental
    &#34;&#34;&#34;

    # initialise optimisation problem
    model = gp.Model(&#34;value_chain&#34;)

    # initialise variables whose scope is this function
    b = {}  # binary variable, represents open/close decisions
    x = {}  # continuous variable, represents material flows

    # add solution variables to the optimisation problem
    # product flows from S to OCF
    for p in self.P:
        for i in self.S:
            for j in self.OCF:
                # Source &gt; Collection Facility
                x[p, i, j] = model.addVar(
                    vtype=&#34;CONTINUOUS&#34;, lb=0, name=&#34;x(%s,%s,%s)&#34; % (p, i, j)
                )
    # product flows from OCF to MPF
    for p in self.P:
        for j in self.OCF:
            for k in self.MPF:
                x[p, j, k] = model.addVar(
                    vtype=&#34;CONTINUOUS&#34;, lb=0, name=&#34;x(%s,%s,%s)&#34; % (p, j, k)
                )
    # product flows from MPF to CPF
    for p in self.P:
        for k in self.MPF:
            for l in self.CPF:
                x[p, k, l] = model.addVar(
                    vtype=&#34;CONTINUOUS&#34;, lb=0, name=&#34;x(%s,%s,%s)&#34; % (p, k, l)
                )
    # product flows from CPF to DPF
    for p in self.P:
        for l in self.CPF:
            for m in self.DPF:
                x[p, l, m] = model.addVar(
                    vtype=&#34;CONTINUOUS&#34;, lb=0, name=&#34;x(%s,%s,%s)&#34; % (p, l, m)
                )
    # product flows from DPF to C
    for p in self.P:
        for m in self.DPF:
            for n in self.C:
                x[p, m, n] = model.addVar(
                    vtype=&#34;CONTINUOUS&#34;, lb=0, name=&#34;x(%s,%s,%s)&#34; % (p, m, n)
                )
    # OCF installation binary outcomes
    for j in self.OCF:
        b[j] = model.addVar(vtype=&#34;INTEGER&#34;, lb=0, name=&#34;b(%s)&#34; % j)
    # MPF installation binary outcomes
    for k in self.MPF:
        b[k] = model.addVar(vtype=&#34;INTEGER&#34;, lb=0, name=&#34;b(%s)&#34; % k)
    # CPF installation binary outcomes
    for l in self.CPF:
        b[l] = model.addVar(vtype=&#34;INTEGER&#34;, lb=0, name=&#34;b(%s)&#34; % l)
    # DPF installation binary outcomes
    for m in self.DPF:
        b[m] = model.addVar(vtype=&#34;INTEGER&#34;, lb=0, name=&#34;b(%s)&#34; % m)

    # add constraint for flow conservation at sources to the model
    for p in self.P:
        for i in self.S:
            model.addConstr(
                gp.quicksum(x[p, i, j] for j in self.OCF)
                == self.source_cap.loc[i, p],
                name=&#34;Conservation(%s,%s)&#34; % (p, i),
            )

    # add constraints for flow conservation at facilities to the model
    for p in self.P:
        for j in self.OCF:
            # input ETICS, output compressed ETICS
            model.addConstr(
                self.yield_factor[(p, &#34;OCF&#34;)]
                * gp.quicksum(x[p, i, j] for i in self.S for p in self.PP)
                == gp.quicksum(x[p, j, k] for k in self.MPF),
                name=&#34;Conservation(%s,%s)&#34; % (p, j),
            )
        for k in self.MPF:
            # input compressed ETICS, output pre-concentrate
            model.addConstr(
                self.yield_factor[(p, &#34;MPF&#34;)]
                * gp.quicksum(x[p, j, k] for j in self.OCF for p in self.PP)
                == gp.quicksum(x[p, k, l] for l in self.CPF),
                name=&#34;Conservation(%s,%s)&#34; % (p, k),
            )
        for l in self.CPF:
            # input pre-concentrate, output pyrolysis oil
            model.addConstr(
                self.yield_factor[(p, &#34;CPF&#34;)]
                * gp.quicksum(x[p, k, l] for k in self.MPF for p in self.PP)
                == gp.quicksum(x[p, l, m] for m in self.DPF),
                name=&#34;Conservation(%s,%s)&#34; % (p, l),
            )
        for m in self.DPF:
            # input pyrolysis oil, output styrene
            model.addConstr(
                self.yield_factor[(p, &#34;DPF&#34;)]
                * gp.quicksum(x[p, l, m] for l in self.CPF for p in self.PP)
                == gp.quicksum(x[p, m, n] for n in self.C),
                name=&#34;Conservation(%s,%s)&#34; % (p, m),
            )

    # add capacity constraint for the facilities to the model
    for j in self.OCF:
        model.addConstr(
            gp.quicksum(x[p, i, j] for i in self.S for p in self.P)
            &lt;= b[j] * self.facility_cap[&#34;OCF&#34;],
            name=&#34;Capacity(%s)&#34; % j,
        )
    for k in self.MPF:
        model.addConstr(
            gp.quicksum(x[p, j, k] for j in self.OCF for p in self.P)
            &lt;= b[k] * self.facility_cap[&#34;MPF&#34;],
            name=&#34;Capacity(%s)&#34; % k,
        )
    for l in self.CPF:
        model.addConstr(
            gp.quicksum(x[p, k, l] for k in self.MPF for p in self.P)
            &lt;= b[l] * self.facility_cap[&#34;CPF&#34;],
            name=&#34;Capacity(%s)&#34; % l,
        )
    for m in self.DPF:
        model.addConstr(
            gp.quicksum(x[p, l, m] for l in self.CPF for p in self.P)
            &lt;= b[m] * self.facility_cap[&#34;DPF&#34;],
            name=&#34;Capacity(%s)&#34; % m,
        )

    # add demand satisfaction constraint to the model
    for p in self.P:
        for n in self.C:
            model.addConstr(
                gp.quicksum(x[p, m, n] for m in self.DPF) &lt;= self.D[(p, n)],
                name=&#34;Demand(%s,%s)&#34; % (p, n),
            )

    # add driving time constraint for OCFs to the model
    for i in self.S:
        for j in self.OCF:
            model.addConstr(
                gp.quicksum(x[p, i, j] for p in self.P) * self.D1.loc[i, j]
                &lt;= (gp.quicksum(x[p, i, j] for p in self.P))
                * self.avg_speed
                * self.max_time,
                name=&#34;Travel Time(%s,%s)&#34; % (j, i),
            )

    # set Gurobi to maximize all objective functions
    model.ModelSense = gp.GRB.MAXIMIZE

    # add economic objective to the model (maximize)
    model.setObjectiveN(
        gp.quicksum(
            self.market_price[p]
            * gp.quicksum(x[p, m, n] for m in self.DPF for n in self.C)
            for p in self.P
        )
        - (
            gp.quicksum(self.ACI_OCF * b[j] for j in self.OCF)
            + gp.quicksum(self.ACI_MPF * b[k] for k in self.MPF)
            + gp.quicksum(self.ACI_CPF * b[l] for l in self.CPF)
            + gp.quicksum(self.ACI_DPF * b[m] for m in self.DPF)
        )
        - (
            gp.quicksum(
                (
                    self.fOPEX_OCF * b[j]
                    + self.vOPEX_OCF
                    * gp.quicksum(x[p, i, j] for i in self.S for p in self.P)
                )
                for j in self.OCF
            )
            + gp.quicksum(
                (
                    self.fOPEX_MPF * b[k]
                    + self.vOPEX_MPF
                    * gp.quicksum(x[p, j, k] for j in self.OCF for p in self.P)
                )
                for k in self.MPF
            )
            + gp.quicksum(
                (
                    self.fOPEX_CPF * b[l]
                    + self.vOPEX_CPF
                    * gp.quicksum(x[p, k, l] for k in self.MPF for p in self.P)
                )
                for l in self.CPF
            )
            + gp.quicksum(
                (
                    self.fOPEX_DPF * b[m]
                    + self.vOPEX_DPF
                    * gp.quicksum(x[p, l, m] for l in self.CPF for p in self.P)
                )
                for m in self.DPF
            )
        )
        - (
            gp.quicksum(
                2 * self.D1.loc[i, j] * self.TC_ETICS * x[p, i, j]
                for i in self.S
                for j in self.OCF
                for p in self.P
            )
            + gp.quicksum(
                2 * self.D2.loc[j, k] * self.TC_comp_ETICS * x[p, j, k]
                for j in self.OCF
                for k in self.MPF
                for p in self.P
            )
            + gp.quicksum(
                2 * self.D3.loc[k, l] * self.TC_pre_concentrate * x[p, k, l]
                for k in self.MPF
                for l in self.CPF
                for p in self.P
            )
            + gp.quicksum(
                2 * self.D4.loc[l, m] * self.TC_pyrolysis_oil * x[p, l, m]
                for l in self.CPF
                for m in self.DPF
                for p in self.P
            )
            + gp.quicksum(
                2 * self.D5.loc[m, n] * self.TC_styrene * x[p, m, n]
                for m in self.DPF
                for n in self.C
                for p in self.P
            )
        ),
        0,
        weight=weight_economic,
        name=&#34;obj_economic&#34;,
    )

    # add environmental objective to the model (minimize = -1 * maximize)
    # NOTE: convert to estimated economic cost so blended MOO works
    model.setObjectiveN(
        -1
        * self.env_cost
        * (
            gp.quicksum(
                (self.CI_OCF + self.OI_OCF)
                * gp.quicksum(x[p, i, j] for i in self.S for p in self.P)
                for j in self.OCF
            )
            + gp.quicksum(
                (self.CI_MPF + self.OI_MPF)
                * gp.quicksum(x[p, j, k] for j in self.OCF for p in self.P)
                for k in self.MPF
            )
            + gp.quicksum(
                (self.CI_CPF + self.OI_CPF)
                * gp.quicksum(x[p, k, l] for k in self.MPF for p in self.P)
                for l in self.CPF
            )
            + gp.quicksum(
                (self.CI_DPF + self.OI_DPF)
                * gp.quicksum(x[p, l, m] for l in self.CPF for p in self.P)
                for m in self.DPF
            )
            + gp.quicksum(
                2 * self.D1.loc[i, j] * self.TI_ETICS * x[p, i, j]
                for i in self.S
                for j in self.OCF
                for p in self.P
            )
            + gp.quicksum(
                2 * self.D2.loc[j, k] * self.TI_comp_ETICS * x[p, j, k]
                for j in self.OCF
                for k in self.MPF
                for p in self.P
            )
            + gp.quicksum(
                2 * self.D3.loc[k, l] * self.TI_pre_concentrate * x[p, k, l]
                for k in self.MPF
                for l in self.CPF
                for p in self.P
            )
            + gp.quicksum(
                2 * self.D4.loc[l, m] * self.TI_pyrolysis_oil * x[p, l, m]
                for l in self.CPF
                for m in self.DPF
                for p in self.P
            )
            + gp.quicksum(
                2 * self.D5.loc[m, n] * self.TI_styrene * x[p, m, n]
                for m in self.DPF
                for n in self.C
                for p in self.P
            )
        ),
        1,
        weight=weight_environmental,
        name=&#34;obj_environmental&#34;,
    )

    self.x = x
    self.b = b
    self.model = model</code></pre>
</details>
</dd>
<dt id="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.plot_infrastructure"><code class="name flex">
<span>def <span class="ident">plot_infrastructure</span></span>(<span>self, country=None, img_path=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create plot where the nodes are plotted as a scatter plot with the size
of the node corresponding to the amount of waste sourced from it. The
installed facilities (and the presence or lack of customers) is then
indicated by icons which are used to annotate nodes on the plot.</p>
<h2 id="parameters">Parameters</h2>
<p>country (str): optional string containing name of the considered country
in english, used to obtain the country's centre and extremes (northmost
southmost, eastmost, westmost) for setting plot limits</p>
<p>img_path (str): optional string containing the location of the image
file which (if specified) will be used as a background for the generated
plot, REQUIRES <code>country</code> to be specified as well</p>
<h2 id="notes">Notes</h2>
<p>This is a good way for visually inspecting and checking smaller
networks.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_infrastructure(self, country=None, img_path=None):
    &#34;&#34;&#34;
    Create plot where the nodes are plotted as a scatter plot with the size
    of the node corresponding to the amount of waste sourced from it. The
    installed facilities (and the presence or lack of customers) is then
    indicated by icons which are used to annotate nodes on the plot.

    Parameters
    ----------
    country (str): optional string containing name of the considered country
    in english, used to obtain the country&#39;s centre and extremes (northmost
    southmost, eastmost, westmost) for setting plot limits

    img_path (str): optional string containing the location of the image
    file which (if specified) will be used as a background for the generated
    plot, REQUIRES ``country`` to be specified as well

    Notes
    -----
    This is a good way for visually inspecting and checking smaller
    networks.
    &#34;&#34;&#34;

    # convert source_cap DataFrame to list containing row sums
    source_cap_row_sums = self.source_cap.sum(axis=1).to_list()
    # extract source coordinates to list
    sources = pd.read_csv(&#34;results/coordinates_sources.csv&#34;)
    x_coords = sources[&#34;xcord&#34;].to_list()
    y_coords = sources[&#34;ycord&#34;].to_list()
    # extract customer coordinates list
    customers = pd.read_csv(&#34;results/coordinates_customers.csv&#34;)
    x_coords_c = customers[&#34;xcord&#34;].to_list()
    y_coords_c = customers[&#34;ycord&#34;].to_list()

    # obtain plot limits using geocoder if ``country`` is specified
    if country != None:
        # obtain corresponding lats and lngs using Nominatim geocoder
        centre = gc.get_country_coords(country)
        bounding_box = gc.get_country_coords(country, output_as=&#34;boundingbox&#34;)
        # calculate x and y distances to the bottom left and top right corners
        bottom_left = cc.coords_to_distances(
            (bounding_box[0], bounding_box[2]), (centre[0], centre[1])
        )
        top_right = cc.coords_to_distances(
            (bounding_box[1], bounding_box[3]), (centre[0], centre[1])
        )
        # extract the required extents for the plot
        x_min = bottom_left[0]
        x_max = top_right[0]
        y_min = bottom_left[1]
        y_max = top_right[1]
    # otherwise, obtain plot limits based on plotted data
    else:
        length_x = max(x_coords) - min(x_coords)
        length_y = max(y_coords) - min(y_coords)

    # convert name_list of installed facilities into an int_list
    int_list_OCF = name_list_to_int_list(self.name_list_OCF)
    int_list_MPF = name_list_to_int_list(self.name_list_MPF)
    int_list_CPF = name_list_to_int_list(self.name_list_CPF)
    int_list_DPF = name_list_to_int_list(self.name_list_DPF)

    # use source row sums to create scatter plot with scaled source size
    fig, ax = plt.subplots(figsize=(8, 8))
    factor = int(300 / max(source_cap_row_sums))
    size = [factor * val for val in source_cap_row_sums]
    ax.scatter(x_coords, y_coords, c=&#34;k&#34;, s=size, zorder=1)
    ax.set_xlabel(&#34;Horizontal distance [km]&#34;)
    ax.set_ylabel(&#34;Vertical distance [km]&#34;)
    # set corresponding limits to the plot
    if country != None:
        ax.set_xlim(x_min * 1.2, x_max * 1.2)
        ax.set_ylim(y_min * 1.2, y_max * 1.2)
    else:
        ax.set_xlim(min(x_coords) - length_x * 0.2, max(x_coords) + length_x * 0.2)
        ax.set_ylim(min(y_coords) - length_y * 0.2, max(y_coords) + length_y * 0.2)
    # set background image if ``img_path`` has been provided
    if img_path != None and country != None:
        background_img = plt.imread(img_path)
        ax.imshow(background_img, zorder=0, extent=[x_min, x_max, y_min, y_max])
    # chosen offset for annotation from the node
    offset = max(20, self.source_cap.values.max() / 60)
    # annotate nodes where OCFs have been installed
    imagebox = osb.OffsetImage(plt.imread(&#34;icons/OCF.png&#34;), zoom=0.03)
    for value in int_list_OCF:
        ab = osb.AnnotationBbox(
            imagebox,
            xy=(x_coords[value], y_coords[value]),
            xybox=(-offset, 0),
            frameon=False,
            boxcoords=&#34;offset points&#34;,
        )
        plt.gca().add_artist(ab)
    # annotate nodes where MPFs have been installed
    imagebox = osb.OffsetImage(plt.imread(&#34;icons/MPF.png&#34;), zoom=0.03)
    for value in int_list_MPF:
        ab = osb.AnnotationBbox(
            imagebox,
            xy=(x_coords[value], y_coords[value]),
            xybox=(-offset * math.sqrt(2) / 2, offset * math.sqrt(2) / 2),
            frameon=False,
            boxcoords=&#34;offset points&#34;,
        )
        plt.gca().add_artist(ab)
    # annnotate nodes where CPFs have been installed
    imagebox = osb.OffsetImage(plt.imread(&#34;icons/CPF.png&#34;), zoom=0.03)
    for value in int_list_CPF:
        ab = osb.AnnotationBbox(
            imagebox,
            xy=(x_coords[value], y_coords[value]),
            xybox=(0, offset),
            frameon=False,
            boxcoords=&#34;offset points&#34;,
        )
        plt.gca().add_artist(ab)
    # annotate nodes where DPFs have been installed
    imagebox = osb.OffsetImage(plt.imread(&#34;icons/DPF.png&#34;), zoom=0.03)
    for value in int_list_DPF:
        ab = osb.AnnotationBbox(
            imagebox,
            xy=(x_coords[value], y_coords[value]),
            xybox=(offset * math.sqrt(2) / 2, offset * math.sqrt(2) / 2),
            frameon=False,
            boxcoords=&#34;offset points&#34;,
        )
        plt.gca().add_artist(ab)
    # annotate nodes where customers are located
    imagebox = osb.OffsetImage(plt.imread(&#34;icons/C.png&#34;), zoom=0.03)
    for idx in range(0, len(x_coords_c)):
        ab = osb.AnnotationBbox(
            imagebox,
            xy=(x_coords_c[idx], y_coords_c[idx]),
            xybox=(offset, 0),
            frameon=False,
            boxcoords=&#34;offset points&#34;,
        )
        plt.gca().add_artist(ab)
    # set plot title
    plt.title(
        f&#34;SY break-even price: {self.break_even_price:_.2f} [euro/ton SY]\nLCA functional unit: {self.functional_unit:_.2f} [ton CO2eq/ton SY]&#34;.replace(
            &#34;_&#34;, &#34;&#39;&#34;
        )
    )
    fig.savefig(
        &#34;results/infrastructure.pdf&#34;, dpi=1200, bbox_inches=&#34;tight&#34;, pad_inches=0.1
    )</code></pre>
</details>
</dd>
<dt id="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.plot_objective_function_breakdown"><code class="name flex">
<span>def <span class="ident">plot_objective_function_breakdown</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Function for plotting a bar graph where the individual components of
both the economic and environmental objective functions are broken down.
The plot generates an individual subplot for each of the objective
functions.</p>
<h2 id="notes">Notes</h2>
<p>This is an excellent method for comparing where the costs and
environmental impacts occur in different networks.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_objective_function_breakdown(self):
    &#34;&#34;&#34;
    Function for plotting a bar graph where the individual components of
    both the economic and environmental objective functions are broken down.
    The plot generates an individual subplot for each of the objective
    functions.

    Notes
    -----
    This is an excellent method for comparing where the costs and
    environmental impacts occur in different networks.
    &#34;&#34;&#34;

    # define colour scheme used throughout using hex notation
    # colours correspond to: yellow, orange, red, purple, indigo
    colours = [&#34;#ffa600&#34;, &#34;#ff6361&#34;, &#34;#bc5090&#34;, &#34;#58508d&#34;, &#34;#003f5c&#34;]

    # define number of categories
    N = 3

    # clear the figure
    plt.clf()
    # configure figure fonts
    plt.rcParams[&#34;font.size&#34;] = 16

    # define economic subcategories and their values
    ETICS = (self.transportation_cost_1, 0, 0)
    compressed_ETICS = (
        self.transportation_cost_2,
        self.capex_OCF,
        self.opex_OCF,
    )
    pre_concentrate = (
        self.transportation_cost_3,
        self.capex_MPF,
        self.opex_MPF,
    )
    pyrolysis_oil = (
        self.transportation_cost_4,
        self.capex_CPF,
        self.opex_CPF,
    )
    styrene = (
        self.transportation_cost_5,
        self.capex_DPF,
        self.opex_DPF,
    )

    # define the bottoms using numpy to add the tuples
    bottom3 = np.add(np.array(ETICS), np.array(compressed_ETICS))
    bottom4 = np.add(np.array(bottom3), np.array(pre_concentrate))
    bottom5 = np.add(np.array(bottom4), np.array(pyrolysis_oil))

    # plot the bar graphs for the economic values and save the figure
    ind = np.arange(N)
    width = 0.65
    fig, ax = plt.subplots(figsize=(8, 8))
    b1 = ax.bar(ind, ETICS, width, color=colours[0])
    b2 = ax.bar(ind, compressed_ETICS, width, bottom=ETICS, color=colours[1])
    b3 = ax.bar(
        ind,
        pre_concentrate,
        width,
        bottom=bottom3,
        color=colours[2],
    )
    b4 = ax.bar(
        ind,
        pyrolysis_oil,
        width,
        bottom=bottom4,
        color=colours[3],
    )
    b5 = ax.bar(
        ind,
        styrene,
        width,
        bottom=bottom5,
        color=colours[4],
    )
    ax.set_ylabel(&#34;Economic cost [euro/day]&#34;)
    ax.set_xticks(ind, (&#34;TC&#34;, &#34;CAPEX&#34;, &#34;OPEX&#34;))
    ax.legend(
        (b1[0], b2[0], b3[0], b4[0], b5[0]),
        (
            &#34;ET&#34;,
            &#34;CE or OCF&#34;,
            &#34;PC or MPF&#34;,
            &#34;PO or CPF&#34;,
            &#34;SY or DPF&#34;,
        ),
        loc=&#34;upper left&#34;,
    )
    ax.set_title(
        f&#34;Total economic cost: {abs(self.obj_economic - self.Revenue):_.2f} euro/day&#34;.replace(
            &#34;_&#34;, &#34;&#39;&#34;
        )
    )
    fig.savefig(
        &#34;results/economic_objective_breakdown.pdf&#34;,
        dpi=1200,
        bbox_inches=&#34;tight&#34;,
        pad_inches=0.1,
    )

    # clear the figure
    plt.clf()

    # define environmental subcategories and their values
    ETICS = (float(self.transportation_impact_1), float(0), float(0))
    compressed_ETICS = (
        self.transportation_impact_2,
        self.construction_impact_OCF,
        self.operational_impact_OCF,
    )
    pre_concentrate = (
        self.transportation_impact_3,
        self.construction_impact_MPF,
        self.operational_impact_MPF,
    )
    pyrolysis_oil = (
        self.transportation_impact_4,
        self.construction_impact_CPF,
        self.operational_impact_CPF,
    )
    styrene = (
        self.transportation_impact_5,
        self.construction_impact_DPF,
        self.operational_impact_DPF,
    )

    # define the bottoms using numpy to add the tuples
    bottom3 = np.add(np.array(ETICS), np.array(compressed_ETICS))
    bottom4 = np.add(np.array(bottom3), np.array(pre_concentrate))
    bottom5 = np.add(np.array(bottom4), np.array(pyrolysis_oil))

    # plot the bar graphs for the environmental values and save the figure
    ind = np.arange(N)
    width = 0.65
    fig, ax = plt.subplots(figsize=(8, 8))
    b1 = ax.bar(ind, ETICS, width, color=colours[0])
    b2 = ax.bar(ind, compressed_ETICS, width, bottom=ETICS, color=colours[1])
    b3 = ax.bar(
        ind,
        pre_concentrate,
        width,
        bottom=bottom3,
        color=colours[2],
    )
    b4 = ax.bar(
        ind,
        pyrolysis_oil,
        width,
        bottom=bottom4,
        color=colours[3],
    )
    b5 = ax.bar(
        ind,
        styrene,
        width,
        bottom=bottom5,
        color=colours[4],
    )
    ax.set_ylabel(&#34;Environmental impact [tons CO2-eq/day]&#34;)
    ax.set_xticks(ind, (&#34;TI&#34;, &#34;CI&#34;, &#34;OI&#34;))
    ax.legend(
        (b1[0], b2[0], b3[0], b4[0], b5[0]),
        (
            &#34;ET&#34;,
            &#34;CE or OCF&#34;,
            &#34;PC or MPF&#34;,
            &#34;PO or CPF&#34;,
            &#34;SY or DPF&#34;,
        ),
        loc=&#34;upper left&#34;,
    )
    ax.set_title(
        f&#34;Total environmental impact: {self.obj_environmental/self.env_cost:_.2f} tons CO2-eq/day&#34;.replace(
            &#34;_&#34;, &#34;&#39;&#34;
        )
    )
    fig.savefig(
        &#34;results/environmental_objective_breakdown.pdf&#34;,
        dpi=1200,
        bbox_inches=&#34;tight&#34;,
        pad_inches=0.1,
    )</code></pre>
</details>
</dd>
<dt id="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.plot_product_flow"><code class="name flex">
<span>def <span class="ident">plot_product_flow</span></span>(<span>self, country=None, img_path=None, layered=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a plot where product flows are plotted between nodes represented
by a scatter plot. The nodes of the scatter plot are scaled according to
the amount of waste available at them. Product interchange between nodes
is represented by a line connecting them. The lines and nodes are colour
and shape coded according to the facilities installed at the node and
the type of material being transported.</p>
<h2 id="parameters">Parameters</h2>
<p>country (str): optional string containing name of the considered country
in english, used to obtain the country's centre and extremes (northmost
southmost, eastmost, westmost) for setting plot limits</p>
<p>img_path (str): optional string containing the location of the image
file which (if specified) will be used as a background for the generated
plot, REQUIRES <code>country</code> to be specified as well</p>
<p>layered (bool): optional boolean which is False by default, if set to
True then the default figure will be generated along with a series of
figures where the product flow is separeted into layers by plotting each
product flow type in a separate figure (the layered visualisation is
useful for analysing complex or very large networks)</p>
<h2 id="notes">Notes</h2>
<p>This is a good way for visually inspecting and checking larger networks.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_product_flow(self, country=None, img_path=None, layered=False):
    &#34;&#34;&#34;
    Create a plot where product flows are plotted between nodes represented
    by a scatter plot. The nodes of the scatter plot are scaled according to
    the amount of waste available at them. Product interchange between nodes
    is represented by a line connecting them. The lines and nodes are colour
    and shape coded according to the facilities installed at the node and
    the type of material being transported.

    Parameters
    ----------
    country (str): optional string containing name of the considered country
    in english, used to obtain the country&#39;s centre and extremes (northmost
    southmost, eastmost, westmost) for setting plot limits

    img_path (str): optional string containing the location of the image
    file which (if specified) will be used as a background for the generated
    plot, REQUIRES ``country`` to be specified as well

    layered (bool): optional boolean which is False by default, if set to
    True then the default figure will be generated along with a series of
    figures where the product flow is separeted into layers by plotting each
    product flow type in a separate figure (the layered visualisation is
    useful for analysing complex or very large networks)

    Notes
    -----
    This is a good way for visually inspecting and checking larger networks.
    &#34;&#34;&#34;

    # define colour scheme used throughout using hex notation
    # colours correspond to: yellow, orange, red, purple, indigo
    colours = [&#34;#ffa600&#34;, &#34;#ff6361&#34;, &#34;#bc5090&#34;, &#34;#58508d&#34;, &#34;#003f5c&#34;]

    # convert source_cap DataFrame to list containing row sums
    source_cap_row_sums = self.source_cap.sum(axis=1).to_list()
    # extract source coordinates to list
    sources = pd.read_csv(&#34;results/coordinates_sources.csv&#34;)
    x_coords = sources[&#34;xcord&#34;].to_list()
    y_coords = sources[&#34;ycord&#34;].to_list()
    # convert name_list of installed facilities into an int_list
    int_list_OCF = name_list_to_int_list(self.name_list_OCF)
    int_list_MPF = name_list_to_int_list(self.name_list_MPF)
    int_list_CPF = name_list_to_int_list(self.name_list_CPF)
    int_list_DPF = name_list_to_int_list(self.name_list_DPF)
    # create manual symbols for legend
    point_S = mlines.Line2D(
        [0],
        [0],
        label=&#34;only S&#34;,
        marker=&#34;o&#34;,
        markersize=10,
        markeredgecolor=colours[0],
        markerfacecolor=colours[0],
        linestyle=&#34;&#34;,
    )
    point_OCF = mlines.Line2D(
        [0],
        [0],
        label=&#34;up to OCF&#34;,
        marker=&#34;o&#34;,
        markersize=10,
        markeredgecolor=colours[1],
        markerfacecolor=colours[1],
        linestyle=&#34;&#34;,
    )
    point_MPF = mlines.Line2D(
        [0],
        [0],
        label=&#34;up to MPF&#34;,
        marker=&#34;o&#34;,
        markersize=10,
        markeredgecolor=colours[2],
        markerfacecolor=colours[2],
        linestyle=&#34;&#34;,
    )
    point_CPF = mlines.Line2D(
        [0],
        [0],
        label=&#34;up to CPF&#34;,
        marker=&#34;o&#34;,
        markersize=10,
        markeredgecolor=colours[3],
        markerfacecolor=colours[3],
        linestyle=&#34;&#34;,
    )
    point_DPF = mlines.Line2D(
        [0],
        [0],
        label=&#34;up to DPF&#34;,
        marker=&#34;o&#34;,
        markersize=10,
        markeredgecolor=colours[4],
        markerfacecolor=colours[4],
        linestyle=&#34;&#34;,
    )
    line_ET = mlines.Line2D(
        [0],
        [0],
        label=&#34;ETICS flow&#34;,
        c=colours[0],
    )
    line_CE = mlines.Line2D(
        [0],
        [0],
        label=&#34;compressed ETICS flow&#34;,
        c=colours[1],
    )
    line_PC = mlines.Line2D(
        [0],
        [0],
        label=&#34;pre-concentrate flow&#34;,
        c=colours[2],
    )
    line_PO = mlines.Line2D(
        [0],
        [0],
        label=&#34;pyrolysis oil flow&#34;,
        c=colours[3],
    )
    line_PS = mlines.Line2D(
        [0],
        [0],
        label=&#34;styrene flow&#34;,
        c=colours[4],
    )
    # obtain plot limits using geocoder if ``country`` is specified
    if country != None:
        # obtain corresponding lats and lngs using Nominatim geocoder
        centre = gc.get_country_coords(country)
        bounding_box = gc.get_country_coords(country, output_as=&#34;boundingbox&#34;)
        # calculate x and y distances to the bottom left and top right corners
        bottom_left = cc.coords_to_distances(
            (bounding_box[0], bounding_box[2]), (centre[0], centre[1])
        )
        top_right = cc.coords_to_distances(
            (bounding_box[1], bounding_box[3]), (centre[0], centre[1])
        )
        # extract the required extents for the plot
        x_min = bottom_left[0]
        x_max = top_right[0]
        y_min = bottom_left[1]
        y_max = top_right[1]
    # otherwise, obtain plot limits based on plotted data
    else:
        length_x = max(x_coords) - min(x_coords)
        length_y = max(y_coords) - min(y_coords)

    # create the default unlayered figure
    fig, ax = plt.subplots(figsize=(8, 8))
    ax.set_xlabel(&#34;Horizontal distance [km]&#34;)
    ax.set_ylabel(&#34;Vertical distance [km]&#34;)
    # set corresponding limits to the plot
    if country != None:
        ax.set_xlim(x_min * 1.2, x_max * 1.2)
        ax.set_ylim(y_min * 1.2, y_max * 1.5)
    else:
        ax.set_xlim(min(x_coords) - length_x * 0.2, max(x_coords) + length_x * 0.2)
        ax.set_ylim(min(y_coords) - length_y * 0.2, max(y_coords) + length_y * 0.5)
    # set background image if ``img_path`` has been provided
    if img_path != None and country != None:
        background_img = plt.imread(img_path)
        ax.imshow(background_img, zorder=0, extent=[x_min, x_max, y_min, y_max])
    # loop over the source coordinates (that is, number of nodes)
    factor = int(300 / max(source_cap_row_sums))
    for idx in range(0, len(x_coords)):
        # plot node with select node colour
        if idx in int_list_DPF:
            colour = colours[4]
        elif idx in int_list_CPF:
            colour = colours[3]
        elif idx in int_list_MPF:
            colour = colours[2]
        elif idx in int_list_OCF:
            colour = colours[1]
        else:
            colour = colours[0]
        # plot the node
        plt.scatter(
            x_coords[idx],
            y_coords[idx],
            c=colour,
            s=source_cap_row_sums[idx] * factor,
            zorder=2.5,
        )
    # draw lines representing exchanged products
    product_flows = pd.read_csv(&#34;results/product_flow.csv&#34;)
    for _, row in product_flows.iterrows():
        origin_int = name_to_int(row[&#34;Origin&#34;])
        destination_int = name_to_int(row[&#34;Destination&#34;])
        # draw line only if origin and destination have different node num.
        if origin_int != destination_int:
            # plot line with selected product flow colour
            if row[&#34;Product&#34;] == &#34;ETICS&#34;:
                colour = colours[0]
            elif row[&#34;Product&#34;] == &#34;compressed_ETICS&#34;:
                colour = colours[1]
            elif row[&#34;Product&#34;] == &#34;pre_concentrate&#34;:
                colour = colours[2]
            elif row[&#34;Product&#34;] == &#34;pyrolysis_oil&#34;:
                colour = colours[3]
            else:
                colour = colours[4]
            # draw the corresponding product flow line
            x = (x_coords[origin_int], x_coords[destination_int])
            y = (y_coords[origin_int], y_coords[destination_int])
            plt.plot(x, y, lw=2, c=colour)
            # annotate the line with an arrow showing flow direction
            x_diff = x_coords[destination_int] - x_coords[origin_int]
            y_diff = y_coords[destination_int] - y_coords[origin_int]
            plt.annotate(
                &#34;&#34;,
                xy=(
                    x_coords[origin_int] + 0.8 * x_diff,
                    y_coords[origin_int] + 0.8 * y_diff,
                ),
                xytext=(
                    x_coords[origin_int] + 0.6 * x_diff,
                    y_coords[origin_int] + 0.6 * y_diff,
                ),
                arrowprops=dict(
                    arrowstyle=&#34;-&gt;&#34;, lw=2, color=colour, mutation_scale=25
                ),
                zorder=1,
            )
    plt.legend(
        handles=[
            point_S,
            point_OCF,
            point_MPF,
            point_CPF,
            point_DPF,
            line_ET,
            line_CE,
            line_PC,
            line_PO,
            line_PS,
        ],
        loc=&#34;upper right&#34;,
        ncol=2,
        frameon=False,
    )
    plt.title(
        f&#34;SY break-even price: {self.break_even_price:_.2f} [euro/ton SY]\nLCA functional unit: {self.functional_unit:_.2f} [ton CO2eq/ton SY]&#34;.replace(
            &#34;_&#34;, &#34;&#39;&#34;
        )
    )
    fig.savefig(
        &#34;results/product_flow.pdf&#34;, dpi=1200, bbox_inches=&#34;tight&#34;, pad_inches=0.1
    )

    # create layered figure if specified
    if layered:
        # loop over the number of layers required &amp; clear existing figure
        plt.clf()
        for layer in range(0, len(colours)):
            fig, ax = plt.subplots(figsize=(8, 8))
            ax.set_xlabel(&#34;Horizontal distance [km]&#34;)
            ax.set_ylabel(&#34;Vertical distance [km]&#34;)
            # set corresponding limits to the plot
            if country != None:
                ax.set_xlim(x_min * 1.2, x_max * 1.2)
                ax.set_ylim(y_min * 1.2, y_max * 1.5)
            else:
                ax.set_xlim(
                    min(x_coords) - length_x * 0.2, max(x_coords) + length_x * 0.2
                )
                ax.set_ylim(
                    min(y_coords) - length_y * 0.2, max(y_coords) + length_y * 0.5
                )
            # set background image if ``img_path`` has been provided
            if img_path != None and country != None:
                background_img = plt.imread(img_path)
                ax.imshow(
                    background_img, zorder=0, extent=[x_min, x_max, y_min, y_max]
                )
            # loop over the source coordinates (that is, number of nodes)
            # create a scatter plont of all nodes
            factor = int(300 / max(source_cap_row_sums))
            for idx in range(0, len(x_coords)):
                # plot node with select node colour
                if idx in int_list_DPF:
                    colour = colours[4]
                elif idx in int_list_CPF:
                    colour = colours[3]
                elif idx in int_list_MPF:
                    colour = colours[2]
                elif idx in int_list_OCF:
                    colour = colours[1]
                else:
                    colour = colours[0]
                # plot the node
                plt.scatter(
                    x_coords[idx],
                    y_coords[idx],
                    c=colour,
                    s=source_cap_row_sums[idx] * factor,
                    zorder=2.5,
                )
            # draw lines representing product flow ONLY on current layer
            product_flows = pd.read_csv(&#34;results/product_flow.csv&#34;)
            title = f&#34;Layer: {self.P[layer]} flow&#34;.replace(&#34;_&#34;, &#34; &#34;)
            for _, row in product_flows.iterrows():
                origin_int = name_to_int(row[&#34;Origin&#34;])
                destination_int = name_to_int(row[&#34;Destination&#34;])
                # draw line only if origin &amp; destination have diff node num.
                if origin_int != destination_int:
                    # plot lines only if they should appear on current layer
                    if self.P.index(row[&#34;Product&#34;]) == layer:
                        colour = colours[layer]
                        # draw the corresponding product flow line
                        x = (x_coords[origin_int], x_coords[destination_int])
                        y = (y_coords[origin_int], y_coords[destination_int])
                        plt.plot(x, y, lw=2, c=colour)
                        # annotate w arrow showing flow direction
                        x_diff = x_coords[destination_int] - x_coords[origin_int]
                        y_diff = y_coords[destination_int] - y_coords[origin_int]
                        plt.annotate(
                            &#34;&#34;,
                            xy=(
                                x_coords[origin_int] + 0.8 * x_diff,
                                y_coords[origin_int] + 0.8 * y_diff,
                            ),
                            xytext=(
                                x_coords[origin_int] + 0.6 * x_diff,
                                y_coords[origin_int] + 0.6 * y_diff,
                            ),
                            arrowprops=dict(
                                arrowstyle=&#34;-&gt;&#34;,
                                lw=2,
                                color=colour,
                                mutation_scale=25,
                            ),
                            zorder=1,
                        )
                    else:
                        continue
            # finish annotating figure and save it
            plt.legend(
                handles=[
                    point_S,
                    point_OCF,
                    point_MPF,
                    point_CPF,
                    point_DPF,
                    line_ET,
                    line_CE,
                    line_PC,
                    line_PO,
                    line_PS,
                ],
                loc=&#34;upper right&#34;,
                ncol=2,
                frameon=False,
            )
            plt.title(title)
            file_name = f&#34;results/product_flow_layer{layer}.pdf&#34;
            fig.savefig(file_name, dpi=1200, bbox_inches=&#34;tight&#34;, pad_inches=0.1)</code></pre>
</details>
</dd>
<dt id="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.process_results"><code class="name flex">
<span>def <span class="ident">process_results</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Process results for the optimised solution. This function accesses
solution variables and computes other relevant secondary variables.
NOTE: this function MUST be called if any further post-processing of the
results is to be done.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_results(self):
    &#34;&#34;&#34;
    Process results for the optimised solution. This function accesses
    solution variables and computes other relevant secondary variables.
    NOTE: this function MUST be called if any further post-processing of the
    results is to be done.
    &#34;&#34;&#34;

    # extract resulting variable values and store them in a dictionary
    vars = {}
    for var in self.model.getVars():
        vars[f&#34;{var.varName}&#34;] = var.x

    # access and store both objective functions (profit &amp; environmental
    # impact expressed as an economic cost)
    self.obj_economic = self.model.getObjective(0).getValue()
    self.obj_environmental = -1 * self.model.getObjective(1).getValue()

    # create ``product_flow`` df for products flowing between facilities
    columns = [&#34;Origin&#34;, &#34;Destination&#34;, &#34;Product&#34;, &#34;Amount&#34;]
    self.product_flow = pd.DataFrame(columns=columns)

    # calculate and store the demand satisfaction
    demand_satisfaction = {}
    for p in self.P:
        for n in self.C:
            demand_satisfaction[(p, n)] = sum(
                vars[f&#34;x({p},{m},{n})&#34;] for m in self.DPF
            )
    self.demand_satisfaction = demand_satisfaction

    # calculate and store the revenue
    self.Revenue = sum(
        sum(self.market_price[p] * self.demand_satisfaction[(p, n)] for n in self.C)
        for p in self.P
    )

    # process data related to installed OCFs
    name_list_OCF = []
    for j in self.OCF:
        if vars[f&#34;b({j})&#34;] &gt; 0.5:
            name_list_OCF.append(j)
        # add inflowing products to product_flow
        for p in self.P:
            for i in self.S:
                if vars[f&#34;x({p},{i},{j})&#34;] &gt; 0.001:
                    # append flow data from i to j to DataFrame
                    new_data = {
                        &#34;Origin&#34;: i,
                        &#34;Destination&#34;: j,
                        &#34;Product&#34;: p,
                        &#34;Amount&#34;: vars[f&#34;x({p},{i},{j})&#34;],
                    }
                    self.product_flow = self.product_flow._append(
                        new_data, ignore_index=True
                    )
    self.name_list_OCF = name_list_OCF

    # process data related to installed MPFs
    name_list_MPF = []
    for k in self.MPF:
        if vars[f&#34;b({k})&#34;] &gt; 0.5:
            name_list_MPF.append(k)
        # add inflowing products to product_flow
        for p in self.P:
            for j in self.OCF:
                if vars[f&#34;x({p},{j},{k})&#34;] &gt; 0.001:
                    # append flow data from j to k to DataFrame
                    new_data = {
                        &#34;Origin&#34;: j,
                        &#34;Destination&#34;: k,
                        &#34;Product&#34;: p,
                        &#34;Amount&#34;: vars[f&#34;x({p},{j},{k})&#34;],
                    }
                    self.product_flow = self.product_flow._append(
                        new_data, ignore_index=True
                    )
    self.name_list_MPF = name_list_MPF

    # process data related to installed CPFs
    name_list_CPF = []
    for l in self.CPF:
        if vars[f&#34;b({l})&#34;] &gt; 0.5:
            name_list_CPF.append(l)
        # add inflowing products to product_flow
        for p in self.P:
            for k in self.MPF:
                if vars[f&#34;x({p},{k},{l})&#34;] &gt; 0.001:
                    # append flow data from k to l to DataFrame
                    new_data = {
                        &#34;Origin&#34;: k,
                        &#34;Destination&#34;: l,
                        &#34;Product&#34;: p,
                        &#34;Amount&#34;: vars[f&#34;x({p},{k},{l})&#34;],
                    }
                    self.product_flow = self.product_flow._append(
                        new_data, ignore_index=True
                    )
    self.name_list_CPF = name_list_CPF

    # process data related to installed DPFs
    name_list_DPF = []
    for m in self.DPF:
        if vars[f&#34;b({m})&#34;] &gt; 0.5:
            name_list_DPF.append(m)
        # add inflowing &amp; outflowing products to product flow
        for p in self.P:
            # inflowing products
            for l in self.CPF:
                if vars[f&#34;x({p},{l},{m})&#34;] &gt; 0.001:
                    # append flow data from l to m to DataFrame
                    new_data = {
                        &#34;Origin&#34;: l,
                        &#34;Destination&#34;: m,
                        &#34;Product&#34;: p,
                        &#34;Amount&#34;: vars[f&#34;x({p},{l},{m})&#34;],
                    }
                    self.product_flow = self.product_flow._append(
                        new_data, ignore_index=True
                    )
            # outflowing products
            for n in self.C:
                if vars[f&#34;x({p},{m},{n})&#34;] &gt; 0.001:
                    # append flow data from m to n to DataFrame
                    new_data = {
                        &#34;Origin&#34;: m,
                        &#34;Destination&#34;: n,
                        &#34;Product&#34;: p,
                        &#34;Amount&#34;: vars[f&#34;x({p},{m},{n})&#34;],
                    }
                    self.product_flow = self.product_flow._append(
                        new_data, ignore_index=True
                    )
    self.name_list_DPF = name_list_DPF

    # save the ``self.product_flow`` DataFrame to a csv file
    self.product_flow.to_csv(&#34;results/product_flow.csv&#34;)

    # compute demand satisfaction of all customers in value chain
    demand_satisfaction = {}
    for p in self.P:
        for n in self.C:
            demand_satisfaction[(p, n)] = sum(
                vars[f&#34;x({p},{m},{n})&#34;] for m in self.DPF
            )
    self.demand_satisfaction = demand_satisfaction

    # compute individual elements of the economic objective function
    # revenue
    self.Revenue = sum(
        sum(self.market_price[p] * self.demand_satisfaction[(p, n)] for n in self.C)
        for p in self.P
    )
    # transportation costs
    # transportation costs between S and OCF
    self.transportation_cost_1 = sum(
        2
        * self.D1.loc[i, j]
        * self.TC_ETICS
        * sum(vars[f&#34;x({p},{i},{j})&#34;] for p in self.P)
        for i in self.S
        for j in self.OCF
    )
    # transportation costs between OCF and MPF
    self.transportation_cost_2 = sum(
        2
        * self.D2.loc[j, k]
        * self.TC_comp_ETICS
        * sum(vars[f&#34;x({p},{j},{k})&#34;] for p in self.P)
        for j in self.OCF
        for k in self.MPF
    )
    # transportation cost between MPF and CPF
    self.transportation_cost_3 = sum(
        2
        * self.D3.loc[k, l]
        * self.TC_pre_concentrate
        * sum(vars[f&#34;x({p},{k},{l})&#34;] for p in self.P)
        for k in self.MPF
        for l in self.CPF
    )
    # transportation cost between CPF and DPF
    self.transportation_cost_4 = sum(
        2
        * self.D4.loc[l, m]
        * self.TC_pyrolysis_oil
        * sum(vars[f&#34;x({p},{l},{m})&#34;] for p in self.P)
        for l in self.CPF
        for m in self.DPF
    )
    # transportation cost between DPF and C
    self.transportation_cost_5 = sum(
        2
        * self.D5.loc[m, n]
        * self.TC_styrene
        * sum(vars[f&#34;x({p},{m},{n})&#34;] for p in self.P)
        for m in self.DPF
        for n in self.C
    )
    # CAPEX of facilities in the value chain
    self.capex_OCF = sum(self.ACI_OCF * vars[f&#34;b({j})&#34;] for j in self.OCF)
    self.capex_MPF = sum(self.ACI_MPF * vars[f&#34;b({k})&#34;] for k in self.MPF)
    self.capex_CPF = sum(self.ACI_CPF * vars[f&#34;b({l})&#34;] for l in self.CPF)
    self.capex_DPF = sum(self.ACI_DPF * vars[f&#34;b({m})&#34;] for m in self.DPF)
    # OPEX of facilities int he value chain
    self.opex_OCF = sum(
        (
            self.fOPEX_OCF * vars[f&#34;b({j})&#34;]
            + self.vOPEX_OCF
            * sum(vars[f&#34;x({p},{i},{j})&#34;] for i in self.S for p in self.P)
        )
        for j in self.OCF
    )
    self.opex_MPF = sum(
        (
            self.fOPEX_MPF * vars[f&#34;b({k})&#34;]
            + self.vOPEX_MPF
            * sum(vars[f&#34;x({p},{j},{k})&#34;] for j in self.OCF for p in self.P)
        )
        for k in self.MPF
    )
    self.opex_CPF = sum(
        (
            self.fOPEX_CPF * vars[f&#34;b({l})&#34;]
            + self.vOPEX_CPF
            * sum(vars[f&#34;x({p},{k},{l})&#34;] for k in self.MPF for p in self.P)
        )
        for l in self.CPF
    )
    self.opex_DPF = sum(
        (
            self.fOPEX_DPF * vars[f&#34;b({m})&#34;]
            + self.vOPEX_DPF
            * sum(vars[f&#34;x({p},{l},{m})&#34;] for l in self.CPF for p in self.P)
        )
        for m in self.DPF
    )

    # compute individual elements of the environmental objective function
    # transportation impact between S and OCF
    self.transportation_impact_1 = sum(
        2
        * self.D1.loc[i, j]
        * self.TI_ETICS
        * sum(vars[f&#34;x({p},{i},{j})&#34;] for p in self.P)
        for i in self.S
        for j in self.OCF
    )
    # transportation impact between OCF and MPF
    self.transportation_impact_2 = sum(
        2
        * self.D2.loc[j, k]
        * self.TI_comp_ETICS
        * sum(vars[f&#34;x({p},{j},{k})&#34;] for p in self.P)
        for j in self.OCF
        for k in self.MPF
    )
    # transportation impact between MPF and CPF
    self.transportation_impact_3 = sum(
        2
        * self.D3.loc[k, l]
        * self.TI_pre_concentrate
        * sum(vars[f&#34;x({p},{k},{l})&#34;] for p in self.P)
        for k in self.MPF
        for l in self.CPF
    )
    # transportation impact between CPF and DPF
    self.transportation_impact_4 = sum(
        2
        * self.D4.loc[l, m]
        * self.TI_pyrolysis_oil
        * sum(vars[f&#34;x({p},{l},{m})&#34;] for p in self.P)
        for l in self.CPF
        for m in self.DPF
    )
    # transportation impact between DPF and C
    self.transportation_impact_5 = sum(
        2
        * self.D5.loc[m, n]
        * self.TI_styrene
        * sum(vars[f&#34;x({p},{m},{n})&#34;] for p in self.P)
        for m in self.DPF
        for n in self.C
    )
    # construction impact
    self.construction_impact_OCF = sum(
        self.CI_OCF * sum(vars[f&#34;x({p},{i},{j})&#34;] for i in self.S for p in self.P)
        for j in self.OCF
    )
    self.construction_impact_MPF = sum(
        self.CI_MPF * sum(vars[f&#34;x({p},{j},{k})&#34;] for j in self.OCF for p in self.P)
        for k in self.MPF
    )
    self.construction_impact_CPF = sum(
        self.CI_CPF * sum(vars[f&#34;x({p},{k},{l})&#34;] for k in self.MPF for p in self.P)
        for l in self.CPF
    )
    self.construction_impact_DPF = sum(
        self.CI_DPF * sum(vars[f&#34;x({p},{l},{m})&#34;] for l in self.CPF for p in self.P)
        for m in self.DPF
    )
    # operational impact
    self.operational_impact_OCF = sum(
        self.OI_OCF * sum(vars[f&#34;x({p},{i},{j})&#34;] for i in self.S for p in self.P)
        for j in self.OCF
    )
    self.operational_impact_MPF = sum(
        self.OI_MPF * sum(vars[f&#34;x({p},{j},{k})&#34;] for j in self.OCF for p in self.P)
        for k in self.MPF
    )
    self.operational_impact_CPF = sum(
        self.OI_CPF * sum(vars[f&#34;x({p},{k},{l})&#34;] for k in self.MPF for p in self.P)
        for l in self.CPF
    )
    self.operational_impact_DPF = sum(
        self.OI_DPF * sum(vars[f&#34;x({p},{l},{m})&#34;] for l in self.CPF for p in self.P)
        for m in self.DPF
    )

    # compute break-even price of styrene and the LCA&#39;s functional unit
    self.styrene_amount = sum(
        sum(vars[f&#34;x({p},{m},{n})&#34;] for m in self.DPF for p in self.P)
        for n in self.C
    )
    self.break_even_price = (
        abs(self.obj_economic - self.Revenue) / self.styrene_amount
    )
    self.functional_unit = (
        self.obj_environmental / self.env_cost / self.styrene_amount
    )
    print(f&#34;Amount of styrene produced: {self.styrene_amount:.2f} [ton]&#34;)
    print(
        f&#34;Break-even price of styrene: {self.break_even_price:.2f} [euro/ton of styrene]&#34;
    )
    print(
        f&#34;LCA functional unit: {self.functional_unit:.2f} [ton CO2eq/ton of styrene]&#34;
    )</code></pre>
</details>
</dd>
<dt id="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.tabulate_product_flows"><code class="name flex">
<span>def <span class="ident">tabulate_product_flows</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a table with the facility types as columns and the node numbers
as rows. The cells are populated with the amount of product flowing
through a specific type of facility in a specific node [tons/day], along
with the number of facilities installed and their capacity in
parenthesis. Two tables are generated from the results: one through
creating a tex file and callind pdflatex, and one using Seaborn which
displays only teh values (not the number of installed facilities).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tabulate_product_flows(self):
    &#34;&#34;&#34;
    Generate a table with the facility types as columns and the node numbers
    as rows. The cells are populated with the amount of product flowing
    through a specific type of facility in a specific node [tons/day], along
    with the number of facilities installed and their capacity in
    parenthesis. Two tables are generated from the results: one through
    creating a tex file and callind pdflatex, and one using Seaborn which
    displays only teh values (not the number of installed facilities).
    &#34;&#34;&#34;

    # extract resulting variable values and store them in a dictionary
    vars = {}
    for var in self.model.getVars():
        vars[f&#34;{var.varName}&#34;] = var.x

    # read the product_flow csv using pandas
    product_flows = pd.read_csv(&#34;results/product_flow.csv&#34;)

    # generate a pandas dataframe for the tabulation
    columns = [&#34;OCF [ton/day]&#34;, &#34;MPF [ton/day]&#34;, &#34;CPF [ton/day]&#34;, &#34;DPF [ton/day]&#34;]
    tabulated_product_flow = pd.DataFrame(columns=columns)
    tabulated_product_flow.rename_axis(&#34;node&#34;, axis=1)
    # generate another dataframe which will store only the values
    tabulated_product_flow_val = pd.DataFrame(columns=columns)
    tabulated_product_flow_val.rename_axis(&#34;node&#34;, axis=1)

    # loop over the nodes in the network
    sources = pd.read_csv(&#34;results/coordinates_sources.csv&#34;)
    x_coords = sources[&#34;xcord&#34;].to_list()
    for node in range(0, len(x_coords)):
        # filter the df using OCF &amp; current node, then extract info
        name = f&#34;OCF_{node}&#34;
        OCF_amount = 0
        filtered = product_flows[product_flows[&#34;Destination&#34;] == name]
        for _, row in filtered.iterrows():
            OCF_amount += row[&#34;Amount&#34;]
        OCF_installed = abs(vars[f&#34;b({name})&#34;])
        OCF_entry = f&#34;{OCF_amount:.1f} ({OCF_installed:.0f} * {self.facility_cap[&#39;OCF&#39;]:.1f})&#34;
        OCF_entry_val = OCF_amount

        # filter the df using MPF &amp; current node, then extract info
        name = f&#34;MPF_{node}&#34;
        MPF_amount = 0
        filtered = product_flows[product_flows[&#34;Destination&#34;] == name]
        for _, row in filtered.iterrows():
            MPF_amount += row[&#34;Amount&#34;]
        MPF_installed = abs(vars[f&#34;b({name})&#34;])
        MPF_entry = f&#34;{MPF_amount:.1f} ({MPF_installed:.0f} * {self.facility_cap[&#39;MPF&#39;]:.1f})&#34;
        MPF_entry_val = MPF_amount

        # filter the df using CPF &amp; current node, then extract info
        name = f&#34;CPF_{node}&#34;
        CPF_amount = 0
        filtered = product_flows[product_flows[&#34;Destination&#34;] == name]
        for _, row in filtered.iterrows():
            CPF_amount += row[&#34;Amount&#34;]
        CPF_installed = abs(vars[f&#34;b({name})&#34;])
        CPF_entry = f&#34;{CPF_amount:.1f} ({CPF_installed:.0f} * {self.facility_cap[&#39;CPF&#39;]:.1f})&#34;
        CPF_entry_val = CPF_amount

        # filter the df using DPF &amp; current node, then extract info
        name = f&#34;DPF_{node}&#34;
        DPF_amount = 0
        filtered = product_flows[product_flows[&#34;Destination&#34;] == name]
        for _, row in filtered.iterrows():
            DPF_amount += row[&#34;Amount&#34;]
        DPF_installed = abs(vars[f&#34;b({name})&#34;])
        DPF_entry = f&#34;{DPF_amount:.1f} ({DPF_installed:.0f} * {self.facility_cap[&#39;DPF&#39;]:.1f})&#34;
        DPF_entry_val = DPF_amount

        # construct new data for this node and append it to the dataframe
        new_data = {
            &#34;OCF [ton/day]&#34;: OCF_entry,
            &#34;MPF [ton/day]&#34;: MPF_entry,
            &#34;CPF [ton/day]&#34;: CPF_entry,
            &#34;DPF [ton/day]&#34;: DPF_entry,
        }
        tabulated_product_flow = tabulated_product_flow._append(
            new_data, ignore_index=True
        )
        # do the same for the dataframe containing only the values
        new_data_val = {
            &#34;OCF [ton/day]&#34;: OCF_entry_val,
            &#34;MPF [ton/day]&#34;: MPF_entry_val,
            &#34;CPF [ton/day]&#34;: CPF_entry_val,
            &#34;DPF [ton/day]&#34;: DPF_entry_val,
        }
        tabulated_product_flow_val = tabulated_product_flow_val._append(
            new_data_val, ignore_index=True
        )

    # name index columns of both dataframes
    tabulated_product_flow.index.name = &#34;node&#34;
    tabulated_product_flow_val.index.name = &#34;node&#34;

    # save the dataframe as a table in pdf format using latex
    filename = &#34;results/tabulated_product_flow.tex&#34;
    directory = &#34;results/&#34;
    template = r&#34;&#34;&#34;\documentclass[preview]{{standalone}}
    \usepackage{{booktabs}}
    \begin{{document}}
    {}
    \end{{document}}
    &#34;&#34;&#34;
    with open(filename, &#34;w&#34;) as f:
        f.write(template.format(tabulated_product_flow.to_latex()))
    # subprocess.call([&#34;pdflatex&#34;, filename])
    subprocess.run(
        [&#34;pdflatex&#34;, &#34;-output-directory=&#34; + directory, filename],
        stdout=subprocess.PIPE,
    )
    # generate Seaborn heatmap
    plt.clf()
    sns.heatmap(
        tabulated_product_flow_val,
        annot=True,
        cmap=&#34;Reds&#34;,
        yticklabels=tabulated_product_flow_val.index[::-1],
    )
    plt.savefig(
        &#34;results/tabulated_product_flow_heatmap.pdf&#34;,
        dpi=1200,
        bbox_inches=&#34;tight&#34;,
        pad_inches=0.1,
    )</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="OptimisedWasteNetworksPy.src" href="index.html">OptimisedWasteNetworksPy.src</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="OptimisedWasteNetworksPy.src.optimisation.name_list_to_int_list" href="#OptimisedWasteNetworksPy.src.optimisation.name_list_to_int_list">name_list_to_int_list</a></code></li>
<li><code><a title="OptimisedWasteNetworksPy.src.optimisation.name_to_int" href="#OptimisedWasteNetworksPy.src.optimisation.name_to_int">name_to_int</a></code></li>
<li><code><a title="OptimisedWasteNetworksPy.src.optimisation.six_tenths_rule" href="#OptimisedWasteNetworksPy.src.optimisation.six_tenths_rule">six_tenths_rule</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="OptimisedWasteNetworksPy.src.optimisation.Infrastructure" href="#OptimisedWasteNetworksPy.src.optimisation.Infrastructure">Infrastructure</a></code></h4>
<ul class="">
<li><code><a title="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.CI_CPF" href="#OptimisedWasteNetworksPy.src.optimisation.Infrastructure.CI_CPF">CI_CPF</a></code></li>
<li><code><a title="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.CI_DPF" href="#OptimisedWasteNetworksPy.src.optimisation.Infrastructure.CI_DPF">CI_DPF</a></code></li>
<li><code><a title="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.CI_MPF" href="#OptimisedWasteNetworksPy.src.optimisation.Infrastructure.CI_MPF">CI_MPF</a></code></li>
<li><code><a title="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.CI_OCF" href="#OptimisedWasteNetworksPy.src.optimisation.Infrastructure.CI_OCF">CI_OCF</a></code></li>
<li><code><a title="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.OI_CPF" href="#OptimisedWasteNetworksPy.src.optimisation.Infrastructure.OI_CPF">OI_CPF</a></code></li>
<li><code><a title="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.OI_DPF" href="#OptimisedWasteNetworksPy.src.optimisation.Infrastructure.OI_DPF">OI_DPF</a></code></li>
<li><code><a title="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.OI_MPF" href="#OptimisedWasteNetworksPy.src.optimisation.Infrastructure.OI_MPF">OI_MPF</a></code></li>
<li><code><a title="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.OI_OCF" href="#OptimisedWasteNetworksPy.src.optimisation.Infrastructure.OI_OCF">OI_OCF</a></code></li>
<li><code><a title="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.avg_speed" href="#OptimisedWasteNetworksPy.src.optimisation.Infrastructure.avg_speed">avg_speed</a></code></li>
<li><code><a title="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.circuit_factor" href="#OptimisedWasteNetworksPy.src.optimisation.Infrastructure.circuit_factor">circuit_factor</a></code></li>
<li><code><a title="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.define_value_chain" href="#OptimisedWasteNetworksPy.src.optimisation.Infrastructure.define_value_chain">define_value_chain</a></code></li>
<li><code><a title="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.driver_hours" href="#OptimisedWasteNetworksPy.src.optimisation.Infrastructure.driver_hours">driver_hours</a></code></li>
<li><code><a title="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.driver_wage" href="#OptimisedWasteNetworksPy.src.optimisation.Infrastructure.driver_wage">driver_wage</a></code></li>
<li><code><a title="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.env_cost" href="#OptimisedWasteNetworksPy.src.optimisation.Infrastructure.env_cost">env_cost</a></code></li>
<li><code><a title="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.env_rolloff" href="#OptimisedWasteNetworksPy.src.optimisation.Infrastructure.env_rolloff">env_rolloff</a></code></li>
<li><code><a title="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.env_tanker" href="#OptimisedWasteNetworksPy.src.optimisation.Infrastructure.env_tanker">env_tanker</a></code></li>
<li><code><a title="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.fuel_cons" href="#OptimisedWasteNetworksPy.src.optimisation.Infrastructure.fuel_cons">fuel_cons</a></code></li>
<li><code><a title="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.fuel_price" href="#OptimisedWasteNetworksPy.src.optimisation.Infrastructure.fuel_price">fuel_price</a></code></li>
<li><code><a title="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.max_time" href="#OptimisedWasteNetworksPy.src.optimisation.Infrastructure.max_time">max_time</a></code></li>
<li><code><a title="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.model_value_chain" href="#OptimisedWasteNetworksPy.src.optimisation.Infrastructure.model_value_chain">model_value_chain</a></code></li>
<li><code><a title="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.period" href="#OptimisedWasteNetworksPy.src.optimisation.Infrastructure.period">period</a></code></li>
<li><code><a title="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.plot_infrastructure" href="#OptimisedWasteNetworksPy.src.optimisation.Infrastructure.plot_infrastructure">plot_infrastructure</a></code></li>
<li><code><a title="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.plot_objective_function_breakdown" href="#OptimisedWasteNetworksPy.src.optimisation.Infrastructure.plot_objective_function_breakdown">plot_objective_function_breakdown</a></code></li>
<li><code><a title="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.plot_product_flow" href="#OptimisedWasteNetworksPy.src.optimisation.Infrastructure.plot_product_flow">plot_product_flow</a></code></li>
<li><code><a title="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.process_results" href="#OptimisedWasteNetworksPy.src.optimisation.Infrastructure.process_results">process_results</a></code></li>
<li><code><a title="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.rate" href="#OptimisedWasteNetworksPy.src.optimisation.Infrastructure.rate">rate</a></code></li>
<li><code><a title="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.ref_CAPEX_CPF" href="#OptimisedWasteNetworksPy.src.optimisation.Infrastructure.ref_CAPEX_CPF">ref_CAPEX_CPF</a></code></li>
<li><code><a title="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.ref_CAPEX_DPF" href="#OptimisedWasteNetworksPy.src.optimisation.Infrastructure.ref_CAPEX_DPF">ref_CAPEX_DPF</a></code></li>
<li><code><a title="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.ref_CAPEX_MPF" href="#OptimisedWasteNetworksPy.src.optimisation.Infrastructure.ref_CAPEX_MPF">ref_CAPEX_MPF</a></code></li>
<li><code><a title="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.ref_CAPEX_OCF" href="#OptimisedWasteNetworksPy.src.optimisation.Infrastructure.ref_CAPEX_OCF">ref_CAPEX_OCF</a></code></li>
<li><code><a title="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.ref_capacity_CPF" href="#OptimisedWasteNetworksPy.src.optimisation.Infrastructure.ref_capacity_CPF">ref_capacity_CPF</a></code></li>
<li><code><a title="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.ref_capacity_DPF" href="#OptimisedWasteNetworksPy.src.optimisation.Infrastructure.ref_capacity_DPF">ref_capacity_DPF</a></code></li>
<li><code><a title="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.ref_capacity_MPF" href="#OptimisedWasteNetworksPy.src.optimisation.Infrastructure.ref_capacity_MPF">ref_capacity_MPF</a></code></li>
<li><code><a title="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.ref_capacity_OCF" href="#OptimisedWasteNetworksPy.src.optimisation.Infrastructure.ref_capacity_OCF">ref_capacity_OCF</a></code></li>
<li><code><a title="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.ref_fOPEX_CPF" href="#OptimisedWasteNetworksPy.src.optimisation.Infrastructure.ref_fOPEX_CPF">ref_fOPEX_CPF</a></code></li>
<li><code><a title="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.ref_fOPEX_DPF" href="#OptimisedWasteNetworksPy.src.optimisation.Infrastructure.ref_fOPEX_DPF">ref_fOPEX_DPF</a></code></li>
<li><code><a title="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.ref_fOPEX_MPF" href="#OptimisedWasteNetworksPy.src.optimisation.Infrastructure.ref_fOPEX_MPF">ref_fOPEX_MPF</a></code></li>
<li><code><a title="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.ref_fOPEX_OCF" href="#OptimisedWasteNetworksPy.src.optimisation.Infrastructure.ref_fOPEX_OCF">ref_fOPEX_OCF</a></code></li>
<li><code><a title="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.rho_ETICS" href="#OptimisedWasteNetworksPy.src.optimisation.Infrastructure.rho_ETICS">rho_ETICS</a></code></li>
<li><code><a title="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.rho_compressed_ETICS" href="#OptimisedWasteNetworksPy.src.optimisation.Infrastructure.rho_compressed_ETICS">rho_compressed_ETICS</a></code></li>
<li><code><a title="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.rho_pre_concentrate" href="#OptimisedWasteNetworksPy.src.optimisation.Infrastructure.rho_pre_concentrate">rho_pre_concentrate</a></code></li>
<li><code><a title="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.rho_pyrolysis_oil" href="#OptimisedWasteNetworksPy.src.optimisation.Infrastructure.rho_pyrolysis_oil">rho_pyrolysis_oil</a></code></li>
<li><code><a title="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.rho_styrene" href="#OptimisedWasteNetworksPy.src.optimisation.Infrastructure.rho_styrene">rho_styrene</a></code></li>
<li><code><a title="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.rolloff_load" href="#OptimisedWasteNetworksPy.src.optimisation.Infrastructure.rolloff_load">rolloff_load</a></code></li>
<li><code><a title="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.rolloff_volume" href="#OptimisedWasteNetworksPy.src.optimisation.Infrastructure.rolloff_volume">rolloff_volume</a></code></li>
<li><code><a title="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.tabulate_product_flows" href="#OptimisedWasteNetworksPy.src.optimisation.Infrastructure.tabulate_product_flows">tabulate_product_flows</a></code></li>
<li><code><a title="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.tanker_volume" href="#OptimisedWasteNetworksPy.src.optimisation.Infrastructure.tanker_volume">tanker_volume</a></code></li>
<li><code><a title="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.toll_cost" href="#OptimisedWasteNetworksPy.src.optimisation.Infrastructure.toll_cost">toll_cost</a></code></li>
<li><code><a title="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.vOPEX_CPF" href="#OptimisedWasteNetworksPy.src.optimisation.Infrastructure.vOPEX_CPF">vOPEX_CPF</a></code></li>
<li><code><a title="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.vOPEX_DPF" href="#OptimisedWasteNetworksPy.src.optimisation.Infrastructure.vOPEX_DPF">vOPEX_DPF</a></code></li>
<li><code><a title="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.vOPEX_MPF" href="#OptimisedWasteNetworksPy.src.optimisation.Infrastructure.vOPEX_MPF">vOPEX_MPF</a></code></li>
<li><code><a title="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.vOPEX_OCF" href="#OptimisedWasteNetworksPy.src.optimisation.Infrastructure.vOPEX_OCF">vOPEX_OCF</a></code></li>
<li><code><a title="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.vehicle_cost_rollof" href="#OptimisedWasteNetworksPy.src.optimisation.Infrastructure.vehicle_cost_rollof">vehicle_cost_rollof</a></code></li>
<li><code><a title="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.vehicle_cost_tanker" href="#OptimisedWasteNetworksPy.src.optimisation.Infrastructure.vehicle_cost_tanker">vehicle_cost_tanker</a></code></li>
<li><code><a title="OptimisedWasteNetworksPy.src.optimisation.Infrastructure.working_days" href="#OptimisedWasteNetworksPy.src.optimisation.Infrastructure.working_days">working_days</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>